<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.0 20120330//EN" "JATS-journalpublishing1.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article">
<front>
<journal-meta>
<journal-id journal-id-type="publisher-id">DS</journal-id>
<journal-title-group><journal-title>Data Science</journal-title></journal-title-group>
<issn pub-type="epub">2451-8492</issn><issn pub-type="ppub">2451-8484</issn><issn-l>2451-8484</issn-l>
<publisher>
<publisher-name>IOS Press</publisher-name><publisher-loc>Nieuwe Hemweg 6B, 1013 BG Amsterdam, The Netherlands</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="publisher-id">DS200030</article-id>
<article-id pub-id-type="doi">10.3233/DS-200030</article-id>
<article-categories><subj-group subj-group-type="heading">
<subject>Research Article</subject></subj-group></article-categories>
<title-group>
<article-title>Application of concepts of neighbours to knowledge graph completion<xref ref-type="fn" rid="thanks1"><sup>1</sup></xref></article-title>
</title-group>
<contrib-group content-type="Editor">
<contrib contrib-type="editor">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-1267-0234</contrib-id>
<name><surname>Kuhn</surname><given-names>Tobias</given-names></name>
</contrib>
</contrib-group>
<contrib-group>
<contrib contrib-type="author">
<contrib-id contrib-id-type="orcid">https://orcid.org/0000-0002-6302-2333</contrib-id>
<name><surname>Ferré</surname><given-names>Sébastien</given-names></name><xref ref-type="aff" rid="affa"/><xref ref-type="corresp" rid="cor2">*</xref>
</contrib>
<aff id="affa"><institution>Univ Rennes, CNRS, IRISA</institution>, <country>France</country>. E-mail: <email>ferre@irisa.fr</email></aff>
</contrib-group>
<author-notes>
<fn id="thanks1"><label>1</label>
<p>This paper is an extended version of a paper published at ESWC’19 (Ferré, <xref ref-type="bibr" rid="ref009">2019</xref>). It is a revised version of submission 622-1602.</p></fn><corresp id="cor2"><label>*</label>Corresponding author. E-mail: <email>ferre@irisa.fr</email>.</corresp>
</author-notes>
<pub-date date-type="preprint" publication-format="electronic"><day>9</day><month>7</month><year>2020</year></pub-date><pub-date date-type="pub" publication-format="electronic"><day>21</day><month>5</month><year>2021</year></pub-date><pub-date date-type="collection" publication-format="electronic"><year>2021</year></pub-date><volume>4</volume><issue>1</issue><fpage>1</fpage><lpage>28</lpage><history><date date-type="received"><day>29</day><month>02</month><year>2020</year></date><date date-type="accepted"><day>3</day><month>06</month><year>2020</year></date></history>
<permissions><copyright-statement>© 2021 – The authors. Published by IOS Press.</copyright-statement><copyright-year>2021</copyright-year>
<license xlink:href="https://creativecommons.org/licenses/by/4.0/" license-type="open-access" xlink:type="simple">
<license-p>This is an open access article distributed under the terms of the <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/" xlink:type="simple">Creative Commons Attribution (CC BY 4.0) License</ext-link>, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions>
<abstract>
<p>The open nature of Knowledge Graphs (KG) often implies that they are incomplete. Knowledge graph completion (a.k.a. link prediction) consists in inferring new relationships between the entities of a KG based on existing relationships. Most existing approaches rely on the learning of latent feature vectors for the encoding of entities and relations. In general however, latent features cannot be easily interpreted. Rule-based approaches offer interpretability but a distinct ruleset must be learned for each relation. In both latent- and rule-based approaches, the training phase has to be run again when the KG is updated. We propose a new approach that does not need a training phase, and that can provide interpretable explanations for each inference. It relies on the computation of Concepts of Nearest Neighbours (C-NN) to identify clusters of similar entities based on common graph patterns. Different rules are then derived from those graph patterns, and combined to predict new relationships. We evaluate our approach on standard benchmarks for link prediction, where it gets competitive performance compared to existing approaches.</p>
</abstract>
<kwd-group>
<label>Keywords</label>
<kwd>Knowledge Graph</kwd>
<kwd>multi-relational data</kwd>
<kwd>knowledge graph completion</kwd>
<kwd>link prediction</kwd>
<kwd>graph pattern</kwd>
<kwd>Concepts of Nearest Neighbours</kwd>
<kwd>inference rules</kwd>
<kwd>analogical inference</kwd>
<kwd>explainable AI</kwd>
</kwd-group>
</article-meta>
</front>
<body>
<sec id="x1-1000-1">
<label>1.</label>
<title>Introduction</title>
<p>There is a growing interest for knowledge graphs (KG) as a way to represent and share data on the Web. The Semantic Web [<xref ref-type="bibr" rid="ref002">2</xref>] defines standards for representation (RDF), querying (SPARQL), and reasoning (RDFS, OWL), and thousands of open KGs are available: e.g., DBpedia, Wikidata (formerly Freebase), YAGO, WordNet. The open nature of KGs often implies that they are incomplete, and a lot of work have studied the use of machine learning techniques to complete them.</p>
<p>The task of <italic>knowledge graph completion</italic>, a.k.a. <italic>link prediction</italic> [<xref ref-type="bibr" rid="ref026">26</xref>], consists in predicting missing edges or missing parts of edges. It is therefore a form of machine learning. Suppose that film <italic>Avatar</italic> is missing a director in the KG, one wants to predict it, i.e. identify it among all KG nodes. The idea is to find regularities in the existing knowledge, and to exploit them in order to rank KG nodes. The higher the correct node is in the ranking, the better the prediction is. Link prediction was originally introduced for social networks with a single edge type (a single <italic>relation</italic>) [<xref ref-type="bibr" rid="ref020">20</xref>], and was later extended to multi-relational data and applied to KGs [<xref ref-type="bibr" rid="ref026">26</xref>]. Compared to the classical task of supervised classification, knowledge graph completion faces several challenges. First, there are as many classification problems as there are relations, which count in the hundreds or thousands in KGs. Second, for each relation, the number of “classes” is the number of different <italic>entities</italic> in the range of the relation, which typically counts in the thousands for relations like <italic>spouse</italic> or <italic>birthPlace</italic>. Third, some relations can be multi-valued, like the relation from films to actors.</p>
<p>In this paper, we report on extensive experimental results about a novel approach to knowledge graph completion that is based on <italic>Concepts of Nearest Neighbours (C-NN)</italic>, which were introduced in [<xref ref-type="bibr" rid="ref007">7</xref>], and applied to <italic>query relaxation</italic> in [<xref ref-type="bibr" rid="ref008">8</xref>]. This paper is an extended version of [<xref ref-type="bibr" rid="ref009">9</xref>] that reports on first results about the application of C-NNs to link prediction. In particular, the extension includes an analogical form of inference, and an extensive and deeper experimental evaluation. The C-NN approach introduces a symbolic form of k-NN (k Nearest Neighbours) where numerical distances are replaced by graph patterns that provide an intelligible representation of how similar two entities are.</p>
<p>Our hypothesis is that the partitioning of the KG entities into concepts of neighbours (see Section <xref rid="x1-5000-5">5</xref>) provides a valuable basis for different kinds of inferences. We here focus on knowledge graph completion, i.e. the inference of the missing node of an incomplete edge. The combinatorial aspect of graph patterns over knowledge graphs is tackled by delaying their computation to inference time, which enables to bound the number of C-NNs by the number of entities, and in practice it is generally much smaller. The intensive knowledge-based computation at inference time is managed with in-memory KG indices (as is common in RDF stores), and any-time algorithms for both C-NN computation and inference. This allows us to scale up to standard link prediction benchmarks, which count up to 100K entities. Scaling further to millions of entities like in DBpedia or Wikidata is left for future work.</p>
<p>The contribution of this work is a novel approach to knowledge graph completion that has the following properties:</p>
<list>
<list-item id="x1-1002x-1">
<label>(1)</label>
<p>it is a form of <italic>instance-based learning</italic>, i.e. it can perform inferences without training, and hence accommodate new data without re-training;</p>
</list-item>
<list-item id="x1-1004x-2">
<label>(2)</label>
<p>it is a <italic>symbolic approach</italic>, i.e. it can provide explanations for each inference;</p>
</list-item>
<list-item id="x1-1006x-3">
<label>(3)</label>
<p>it shows <italic>competitive performance</italic> on standard link prediction benchmarks.</p>
</list-item>
</list>
<p>The rest of the paper is organized as follows. Section <xref rid="x1-2000-2">2</xref> discusses related work on knowledge graph completion. Section <xref rid="x1-3000-3">3</xref> contains preliminaries about knowledge graphs and queries. Section <xref rid="x1-4000-4">4</xref> presents an overview of our approach. Section <xref rid="x1-5000-5">5</xref> recalls the definition of C-NNs, and their efficient computation. Section <xref rid="x1-8000-6">6</xref> presents our method to perform C-NN-based knowledge graph completion. Section <xref rid="x1-12000-7">7</xref> reports on positive experimental results on standard benchmarks (WN18, WN18RR, FB15k, FB15k-237), along with an in-depth analysis of results. Finally, Section <xref rid="x1-19000-8">8</xref> concludes and sketches future work.</p>
</sec>
<sec id="x1-2000-2">
<label>2.</label>
<title>Related work</title>
<p>Nickel <italic>et al.</italic> [<xref ref-type="bibr" rid="ref026">26</xref>] published a “review of relational machine learning for knowledge graphs”, where link prediction is the main inference task. They identify two kinds of approaches that differ by the kind of model they use: <italic>latent feature models</italic>, and <italic>graph feature models</italic>. The former is by far the most studied one. Before going into details, it is useful to set the vocabulary as it is used in the domain. Nodes are called <italic>entities</italic>, edge labels are called <italic>relations</italic>, and edges are called <italic>triples</italic> <inline-formula><mml:math id="math001">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, where <inline-formula><mml:math id="math002">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is the <italic>head</italic> entity, <inline-formula><mml:math id="math003">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is the <italic>tail</italic> entity, and <inline-formula><mml:math id="math004">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is the relation that links the head to the tail.</p>
<p>Latent feature models learn <italic>embeddings</italic> of entities and relations into low-dimensional vector spaces, and then make inferences about a triple <inline-formula><mml:math id="math005">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> by combining the embeddings of the two entities and the embedding of the relation. The existing methods vary by how they learn the embeddings, and how they combine them. Those methods are based on a range of techniques including: matrix factorization, tensor factorization, neural networks, and gradient descent. For example, one of the first method for KGs, TransE [<xref ref-type="bibr" rid="ref004">4</xref>], models a relation as a translation in the embedding space of entities, and scores a candidate triple according to the distance between the translated head and the tail. The authors of TransE, Bordes <italic>et al.</italic>, introduced two datasets, FB15k and WN18, respectively derived from Freebase and WordNet, which became benchmarks in the evaluation of link prediction methods. Toutanova and Chen [<xref ref-type="bibr" rid="ref030">30</xref>] however showed that a very simple method was able to outperform previous methods because of a flaw in the datasets: many test triples have their inverse among the training triples. They introduced a challenging subset of FB15k, called FB15k-237, where all inverse triples are removed. Dettmers [<xref ref-type="bibr" rid="ref006">6</xref>] introduced a similar subset of WN18, called WN18RR. Lately, performance was significantly improved on the challenging FB15k-237 by using convolutional architectures to learn embeddings [<xref ref-type="bibr" rid="ref029">29</xref>] or to combine the embeddings in scoring functions [<xref ref-type="bibr" rid="ref006">6</xref>]. The state-of-the-art results are obtained by ComplEx-N3, combining low-rank tensor decomposition with the addition of inverse relations, and various optimizations about hyper-parameters and regularization [<xref ref-type="bibr" rid="ref018">18</xref>]. The task of link prediction has also been extended with the embedding model RAE to <italic>multi-fold relations</italic> (a.k.a. n-ary relations), and to <italic>instance reconstruction</italic> where only one entity of an n-ary relation is known, and all other entities have to be inferred together [<xref ref-type="bibr" rid="ref032">32</xref>]. In this work, we limit ourselves to binary relations, and let those advanced cases for future work.</p>
<p>The latent feature models face two major drawbacks for their application to real settings. First, as they rely on the learning of entity embeddings, they cannot be applied to unseen entities, and the model has to be retrained whenever new entities or relations are introduced in the knowledge graph. Second, the predictions come without any explanation, and the meaning of learned latent features generally remain obscure. Given that it is unrealistic to expect high precision knowledge graph completion, simply because some of the missing information cannot be inferred from existing knowledge, human curation is necessary in practice. An explanation may comfort the curator in the veracity of the prediction, and could even be used to define automated inference rules.</p>
<p>Graph feature models, also called <italic>observed feature models</italic>, make inferences directly from the observed edges in the KG. Random walk inference [<xref ref-type="bibr" rid="ref019">19</xref>] takes relation paths as features, and sets the feature values through random walks in the KG. The feature weights are learned by logistic regression for each target relation, and then used to score the candidate triples. The method has shown improvement over Horn clause generation with ILP (Inductive Logic Programming) [<xref ref-type="bibr" rid="ref025">25</xref>]. AMIE+ [<xref ref-type="bibr" rid="ref011">11</xref>] manages to generate such Horn clauses in a much more efficient way by designing new ILP algorithms tailored to KGs. They also introduce a novel rule measure that improves the inference precision under the Open World Assumption (OWA) that holds in KGs. A fine-grained evaluation [<xref ref-type="bibr" rid="ref024">24</xref>] has shown that rule-based approaches are competitive with latent-based approaches, both in performance and in running time. AnyBURL [<xref ref-type="bibr" rid="ref023">23</xref>] restricts to path-like Horn clauses, and employs an anytime bottom-up strategy for learning rules. It significantly improves performance compared to AMIE+, and gets close to the state-of-the-art of latent feature models. Graph feature models, especially rule-based approaches, offer the advantage to produce intelligible explanations for inferences, unlike the latent feature models. Moreover, they can be applied to unseen entities because inferences are based on the neighborhood of the entity in the knowledge graph, rather than on a learned embedding. However, they require a distinct training phase for each of the possibly many target relations, whereas the latent feature models are generally learned in one training phase. A drawback of both kinds of approaches is that new embeddings and new rulesets need to be learned whenever the KG is updated, which becomes a challenge for dynamic data.</p>
<p>Our approach relies on graph features but a key difference is that there is no training phase, and all the learning is done at inference time. It is therefore an instance-based approach rather than a model-based approach. Given an incomplete triple <inline-formula><mml:math id="math006">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo>?</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> we compute Concepts of Nearest Neighbours (C-NN) from the observed features of head entity <inline-formula><mml:math id="math007">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, where C-NNs have a representation equivalent to the bodies of AMIE+’s rules. From there, we infer a ranking of candidate entities for the tail of relation <inline-formula><mml:math id="math008">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. In fact, as <inline-formula><mml:math id="math009">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is not involved in the computation of C-NNs, many target relations can be inferred at nearly the same cost as a single relation. Indeed the main cost is in the computation of C-NNs, which is easily controlled because the computation algorithm is anytime. Compared to rule-based approaches, it amounts to compute only rule bodies that match the head entity <inline-formula><mml:math id="math010">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, and to add the rule head according to relation <inline-formula><mml:math id="math011">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>.</p>
</sec>
<sec id="x1-3000-3">
<label>3.</label>
<title>Preliminaries</title>
<p>A <italic>knowledge graph</italic> (KG) is defined by a structure <inline-formula><mml:math id="math012">
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo fence="true" stretchy="false">⟨</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">R</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">T</mml:mi>
<mml:mo fence="true" stretchy="false">⟩</mml:mo></mml:math></inline-formula>, where <italic>E</italic> is the set of nodes, also called <italic>entities</italic>, <italic>R</italic> is the set of edge labels, also called <italic>relations</italic>, and <inline-formula><mml:math id="math013">
<mml:mi mathvariant="italic">T</mml:mi>
<mml:mo stretchy="false">⊆</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi>
<mml:mo>×</mml:mo>
<mml:mi mathvariant="italic">R</mml:mi>
<mml:mo>×</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi></mml:math></inline-formula> is the set of directed and labelled edges, also called <italic>triples</italic>. Each triple <inline-formula><mml:math id="math014">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> represents the fact that relation <inline-formula><mml:math id="math015">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> relates entity <inline-formula><mml:math id="math016">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> to entity <inline-formula><mml:math id="math017">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. This definition is very close to RDF graphs, where entities can be either URIs or literals (or blank nodes) and relations are URIs called properties. It is also equivalent to sets of logical facts, where entities are constants, and relations are binary predicates.</p>
<p>As a running example, Fig. <xref rid="x1-3001-1">1</xref> defines a small KG describing (part of) the British royal family (where <inline-formula><mml:math id="math018">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">a</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">b</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">r</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">c</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">d</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is a compact notation for <inline-formula><mml:math id="math019">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">a</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">r</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">c</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">a</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">r</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">d</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">b</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">r</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">c</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">b</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">r</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">d</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>).</p>
<fig id="x1-3001-1">
<label>Fig. 1.</label>
<caption>
<p>Example knowledge graph describing part of the British royal family.</p>
</caption>
<graphic xlink:href="ds-4-ds200030-g001.jpg"/>
</fig>
<p><italic>Queries</italic> based on <italic>graph patterns</italic> play a central role in our approach as they are used to characterize the C-NNs, and can be used as explanations for inferences. There are two kinds of <italic>query elements</italic>: triple patterns and filters. A <italic>triple pattern</italic> <inline-formula><mml:math id="math020">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">r</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">V</mml:mi>
<mml:mo>×</mml:mo>
<mml:mi mathvariant="italic">R</mml:mi>
<mml:mo>×</mml:mo>
<mml:mi mathvariant="italic">V</mml:mi></mml:math></inline-formula> is similar to a triple but with variables (taken from <italic>V</italic>) in place of entities. A <italic>filter</italic> is a Boolean expression on variables and entities. We here only consider equalities between a variable and an entity (<inline-formula><mml:math id="math021">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">e</mml:mi></mml:math></inline-formula>) and let richer filters about literal values for future work (e.g., inequalities and intervals on numbers and dates, regular expressions on strings). A <italic>graph pattern P</italic> is a set of query elements. <inline-formula><mml:math id="math022">
<mml:mi mathvariant="italic">Vars</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">P</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> denotes the set of variables occurring in <italic>P</italic>. Equality filters are equivalent to allowing entities in triple patterns: e.g., pattern <inline-formula><mml:math id="math023">
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mtext mathvariant="italic">parent</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo>=</mml:mo>
<mml:mtext mathvariant="italic">Kate</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula> is equivalent to the triple pattern <inline-formula><mml:math id="math024">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mtext mathvariant="italic">parent</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mtext mathvariant="italic">Kate</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. There are two advantages in using filters: (1) simplifying the handling of triple patterns that have a single form (var–var) instead of four (var–var, entity–var, var–entity, entity–entity); (2) opening perspectives for richer filters (e.g., <inline-formula><mml:math id="math025">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">&gt;</mml:mo>
<mml:mn>10</mml:mn></mml:math></inline-formula>, <inline-formula><mml:math id="math026">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mo fence="true" stretchy="false">[</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mn>10</mml:mn>
<mml:mo fence="true" stretchy="false">]</mml:mo></mml:math></inline-formula>). A <italic>query</italic> <inline-formula><mml:math id="math027">
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">←</mml:mo>
<mml:mi mathvariant="italic">P</mml:mi></mml:math></inline-formula> is the projection of a graph pattern on a subset of its variables. Such queries find a concrete form in SPARQL with syntax <monospace>SELECT ?x1…?xn WHERE {</monospace> <italic>P</italic> <monospace>}</monospace>. Queries can be seen as anonymous rules, i.e. rules like those in AMIE+ [<xref ref-type="bibr" rid="ref011">11</xref>] but missing the relation in the head. For example, the query <inline-formula><mml:math id="math028">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">ex</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">←</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">male</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> retrieves all (person, uncle) pairs, i.e. all pairs <inline-formula><mml:math id="math029">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> where <italic>y</italic> is a sibling of a parent of <italic>x</italic>, and is male.</p>
<p>We now define the <italic>answer set</italic> that is retrieved by a query. A <italic>matching</italic> of a pattern <italic>P</italic> on a KG <inline-formula><mml:math id="math030">
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo fence="true" stretchy="false">⟨</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">R</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">T</mml:mi>
<mml:mo fence="true" stretchy="false">⟩</mml:mo></mml:math></inline-formula> is a mapping <italic>μ</italic> from <inline-formula><mml:math id="math031">
<mml:mtext mathvariant="italic">Vars</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">P</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> to entities in <italic>E</italic> such that <inline-formula><mml:math id="math032">
<mml:mi mathvariant="italic">μ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">t</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">T</mml:mi></mml:math></inline-formula> for every triple pattern <inline-formula><mml:math id="math033">
<mml:mi mathvariant="italic">t</mml:mi>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">P</mml:mi></mml:math></inline-formula>, and <inline-formula><mml:math id="math034">
<mml:mi mathvariant="italic">μ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">f</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> evaluates to true for every filter <inline-formula><mml:math id="math035">
<mml:mi mathvariant="italic">f</mml:mi>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">P</mml:mi></mml:math></inline-formula>, where <inline-formula><mml:math id="math036">
<mml:mi mathvariant="italic">μ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">t</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math id="math037">
<mml:mi mathvariant="italic">μ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">f</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> are obtained from <italic>t</italic> and <italic>f</italic> by replacing every variable <italic>x</italic> by <inline-formula><mml:math id="math038">
<mml:mi mathvariant="italic">μ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. In the example KG, a possible matching for the pattern of the above query is <inline-formula><mml:math id="math039">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">μ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">ex</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">↦</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo stretchy="false">↦</mml:mo>
<mml:mi mathvariant="italic">Harry</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo stretchy="false">↦</mml:mo>
<mml:mi mathvariant="italic">William</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo stretchy="false">↦</mml:mo>
<mml:mi mathvariant="italic">Diana</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo stretchy="false">↦</mml:mo>
<mml:mi mathvariant="italic">male</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula>. A matching is therefore a homomorphism from the pattern to the graph. Term “matching” is taken from the evaluation of SPARQL queries. In logics, terms “grounding” and “instantiation” are used instead. The <italic>answer set</italic> <inline-formula><mml:math id="math040">
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> of a query <inline-formula><mml:math id="math041">
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">←</mml:mo>
<mml:mi mathvariant="italic">P</mml:mi></mml:math></inline-formula> is the set of tuples <inline-formula><mml:math id="math042">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">μ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">μ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">n</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> obtained from all matchings <italic>μ</italic> of <italic>P</italic> on <italic>K</italic>. In the running example, the pair <inline-formula><mml:math id="math043">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Harry</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is therefore an answer of query <inline-formula><mml:math id="math044">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">ex</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. Note that several matchings can lead to the same answer, and that duplicate answers are ignored. In the following, we only consider queries with a single projected variable, whose sets of answers are assimilated to sets of entities.</p>
</sec>
<sec id="x1-4000-4">
<label>4.</label>
<title>Overview of the approach</title>
<p>Fig. <xref rid="x1-4001-2">2</xref> shows a schematic overview of our approach. Given a knowledge graph and a triple <inline-formula><mml:math id="math045">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, the goal is to predict the link to <inline-formula><mml:math id="math046">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> from <inline-formula><mml:math id="math047">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> through relation <inline-formula><mml:math id="math048">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, i.e. <inline-formula><mml:math id="math049">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is here the unknown to predict. For example, assume triple <inline-formula><mml:math id="math050">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Kate</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is missing in the KG of Fig. <xref rid="x1-3001-1">1</xref>, and we want to predict who is the mother of Charlotte. The first step is to compute a collection of Concepts of Nearest Neighbours (C-NN) <italic>δ</italic> for entity <inline-formula><mml:math id="math051">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> (see Section <xref rid="x1-5000-5">5</xref>). In the example where <inline-formula><mml:math id="math052">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is Charlotte, one C-NN contains Diana and Kate because they have female gender like Charlotte, and another C-NN contains George and Louis because they have William as a parent like Charlotte. The second and third step are to generate a collection of inference rules for each C-NN, and to derive a set of candidate entities from each rule (see Section <xref rid="x1-9000-6.1">6.1</xref>). A candidate entity may be inferred by several rules, possibly generated from different concepts. In the example, a rule generated from the latter C-NN is that “persons who have William as a parent also have Kate as a parent”, and Kate is therefore a candidate for the unknown entity. Finally, the different candidates can be ranked by scoring them based on rule measures such as support and confidence, and the ranking can be evaluated with standard ranking measures such as Hits@N and MRR w.r.t. the expected entity <inline-formula><mml:math id="math053">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> (see Section <xref rid="x1-12000-7">7</xref>).</p>
<fig id="x1-4001-2">
<label>Fig. 2.</label>
<caption>
<p>Overview of link prediction based on concepts of nearest neighbours.</p>
</caption>
<graphic xlink:href="ds-4-ds200030-g002.jpg"/>
</fig>
</sec>
<sec id="x1-5000-5">
<label>5.</label>
<title>Concepts of Nearest Neighbours (C-NN)</title>
<p>In this section, we shortly recall the theoretical definitions underlying Concepts of Nearest Neighbours (C-NN), as well as the algorithmic and practical aspects of their approximate computation under a given timeout. Further details are available in [<xref ref-type="bibr" rid="ref007">7</xref>,<xref ref-type="bibr" rid="ref008">8</xref>]. In the following definitions, we assume a knowledge graph <inline-formula><mml:math id="math054">
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo fence="true" stretchy="false">⟨</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">R</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">T</mml:mi>
<mml:mo fence="true" stretchy="false">⟩</mml:mo></mml:math></inline-formula>.</p>
<sec id="x1-6000-5.1">
<label>5.1.</label>
<title>Theoretical definitions</title>
<p>We start by defining <italic>graph concepts</italic>, introduced in Graph-FCA [<xref ref-type="bibr" rid="ref010">10</xref>], which is a generalization of Formal Concept Analysis (FCA) [<xref ref-type="bibr" rid="ref012">12</xref>] to knowledge graphs. FCA concepts are a formalization of the classical theory of concepts in philosophy, where each concept has two related sides: the <italic>intension</italic> that characterizes what concept instances have in common, and the <italic>extension</italic> that enumerates those instances.</p><statement id="x1-6001r-1"><label>Definition 1.</label>
<p>A <italic>graph concept</italic> is defined as a pair <inline-formula><mml:math id="math055">
<mml:mi mathvariant="italic">C</mml:mi>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">A</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, where <italic>A</italic> is a set of entities and <italic>Q</italic> is a query such that <inline-formula><mml:math id="math056">
<mml:mi mathvariant="italic">A</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is the set of answers of <italic>Q</italic>, and <inline-formula><mml:math id="math057">
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">msq</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">A</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is the most specific query that verifies <inline-formula><mml:math id="math058">
<mml:mi mathvariant="italic">A</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. <italic>A</italic> is called the <italic>extension</italic> <inline-formula><mml:math id="math059">
<mml:mi mathvariant="italic">ext</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">C</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> of the concept, and <italic>Q</italic> is called the <italic>intension</italic> <inline-formula><mml:math id="math060">
<mml:mi mathvariant="italic">int</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">C</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> of the concept.</p></statement>
<p>The most specific query <inline-formula><mml:math id="math061">
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">msq</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">A</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> represents what the neighborhood of entities in <italic>A</italic> have in common. It is well-defined under graph homomorphism (unlike under subgraph isomorphism). It can be computed from <italic>A</italic> by using the categorical product of graphs (see PGP intersection <inline-formula><mml:math id="math062">
<mml:msub>
<mml:mrow>
<mml:mo largeop="false" movablelimits="false">⋂</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">q</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> in [<xref ref-type="bibr" rid="ref010">10</xref>]), or equivalently Plotkin’s anti-unification of sets of facts [<xref ref-type="bibr" rid="ref028">28</xref>]. In the example KG, William and Charlotte have in common the following query that says that they have married parents: 
<disp-formula>
<mml:math display="block" id="math063">
<mml:mtable displaystyle="true" columnspacing="0pt 10pt 0pt 10pt 0pt 10pt 0pt 10pt 0pt 10pt">
<mml:mtr>
<mml:mtd columnalign="right">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WC</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mi mathvariant="italic">msq</mml:mi>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">(</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">William</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">)</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="right">
<mml:mo>=</mml:mo>
</mml:mtd>
<mml:mtd columnalign="left">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="right"/>
<mml:mtd columnalign="left">
<mml:mphantom>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mspace width="2.75pt"/></mml:mphantom>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">t</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">t</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">male</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="right"/>
<mml:mtd columnalign="left">
<mml:mphantom>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mspace width="2.75pt"/></mml:mphantom>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">female</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="right"/>
<mml:mtd columnalign="left">
<mml:mphantom>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mspace width="2.75pt"/></mml:mphantom>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">spouse</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">spouse</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
We have <inline-formula><mml:math id="math064">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WC</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WC</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">William</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Harry</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">George</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Louis</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula> so that <inline-formula><mml:math id="math065">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WC</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WC</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WC</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is a graph concept.</p>
<p>A concept <inline-formula><mml:math id="math066">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is more specific than a concept <inline-formula><mml:math id="math067">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, in notation <inline-formula><mml:math id="math068">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>⩽</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, if <inline-formula><mml:math id="math069">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">⊆</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">A</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. For example, a concept more specific than <inline-formula><mml:math id="math070">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WC</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is the concept of <italic>the children of Kate and William</italic>, whose extension is <inline-formula><mml:math id="math071">
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">George</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Louis</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula>, and whose intension is 
<disp-formula>
<mml:math display="block" id="math072">
<mml:mtable displaystyle="true">
<mml:mtr>
<mml:mtd>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">William</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">Kate</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
The total number of graph concepts in a knowledge graph is finite but in the worst case, it is exponential in the number of entities. It is therefore not feasible in general to compute the set of all concepts.</p>
<p>Instead of considering concepts generated by subsets of entities, we consider concepts generated by pairs of entities, and use them as a symbolic form of distance between entities.</p><statement id="x1-6002r-2"><label>Definition 2.</label>
<p>Let <inline-formula><mml:math id="math073">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi></mml:math></inline-formula> be two entities. The <italic>conceptual distance</italic> <inline-formula><mml:math id="math074">
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> between <inline-formula><mml:math id="math075">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math076">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is the most specific graph concept whose extension contains both entities, i.e. <inline-formula><mml:math id="math077">
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">A</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> with <inline-formula><mml:math id="math078">
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">msq</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, and <inline-formula><mml:math id="math079">
<mml:mi mathvariant="italic">A</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>.</p></statement>
<p>For example, the above concept <inline-formula><mml:math id="math080">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WC</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is the conceptual distance between William and Charlotte. The “distance values” have therefore a symbolic representation through the concept intension <italic>Q</italic> that represents what the two entities have in common. The concept extension <italic>A</italic> contains in addition to the two entities all entities <inline-formula><mml:math id="math081">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> that match the common query (<inline-formula><mml:math id="math082">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>). Such an entity <inline-formula><mml:math id="math083">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> can be seen as “between” <inline-formula><mml:math id="math084">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math085">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>: in formulas, for all <inline-formula><mml:math id="math086">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">ext</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, <inline-formula><mml:math id="math087">
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>⩽</mml:mo>
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math id="math088">
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>⩽</mml:mo>
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. Note that order ⩽ on conceptual distances is a partial ordering, unlike classical distance measures.</p>
<p>A numerical distance <inline-formula><mml:math id="math089">
<mml:mi mathvariant="italic">dist</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
<mml:mi mathvariant="italic">ext</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> can be derived from the size of the concept extension, because the closer <inline-formula><mml:math id="math090">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math091">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> are, the more specific their conceptual distance is, and the smaller the extension is.</p>
<p>For example, the numerical distance is 5 between Charlotte and William (see <inline-formula><mml:math id="math092">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">C</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WC</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>), and 3 between George and Charlotte.</p>
<p>The number of conceptual distances <inline-formula><mml:math id="math093">
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is no more exponential but it is still quadratic in the number of entities. By delaying their computation until we know for which entity <italic>e</italic> predictions are to be made, we fix one of the two entities in <inline-formula><mml:math id="math094">
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, and the number of concepts becomes linear. Those concepts are called <italic>Concepts of Nearest Neighbours (C-NN)</italic>.</p><statement id="x1-6003r-3"><label>Definition 3.</label>
<p>Let <inline-formula><mml:math id="math095">
<mml:mi mathvariant="italic">e</mml:mi>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi></mml:math></inline-formula> be an entity. The <italic>Concepts of Nearest Neighbours (C-NN)</italic> (in short, <italic>concepts of neighbours</italic>) of <italic>e</italic> are all the conceptual distances between <italic>e</italic> and every entity <inline-formula><mml:math id="math096">
<mml:msup>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>′</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi></mml:math></inline-formula>. 
<disp-formula>
<mml:math display="block" id="math097">
<mml:mtable displaystyle="true">
<mml:mtr>
<mml:mtd>
<mml:mspace width="0.1667em"/>
<mml:mtext mathvariant="italic">C-NN</mml:mtext>
<mml:mspace width="0.1667em"/>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">e</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">{</mml:mo>
<mml:mi mathvariant="italic">δ</mml:mi>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">(</mml:mo>
<mml:mi mathvariant="italic">e</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>′</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">)</mml:mo>
<mml:mo stretchy="false">∣</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>′</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula>
</p></statement>
<table-wrap id="x1-6004-1">
<label>Table 1</label>
<caption>
<p>Description of the 6 C-NNs of Charlotte in the royal family KG</p>
</caption>
<table frame="hsides" rules="groups">
<thead>
<tr>
<td valign="top" align="left"><italic>l</italic></td>
<td valign="top" align="center"><inline-formula><mml:math id="math098">
<mml:mi mathvariant="italic">ext</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> (proper in bold)</td>
<td valign="top" align="center"><inline-formula><mml:math id="math099">
<mml:mi mathvariant="italic">int</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula></td>
<td valign="top" align="center">Sub-concepts</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">1</td>
<td valign="top" align="left"><inline-formula><mml:math id="math100">
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mtext mathvariant="bold">Charlotte</mml:mtext>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula></td>
<td valign="top" align="left"><inline-formula><mml:math id="math101">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula></td>
<td valign="top" align="left">–</td>
</tr>
<tr>
<td valign="top" align="left">2</td>
<td valign="top" align="left"><inline-formula><mml:math id="math102">
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mtext mathvariant="bold">Diana</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mtext mathvariant="bold">Kate</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula></td>
<td valign="top" align="left"><inline-formula><mml:math id="math103">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">female</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula></td>
<td valign="top" align="left">1</td>
</tr>
<tr>
<td valign="top" align="left">3</td>
<td valign="top" align="left"><inline-formula><mml:math id="math104">
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mtext mathvariant="bold">George</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mtext mathvariant="bold">Louis</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula></td>
<td valign="top" align="left"><inline-formula><mml:math id="math105">
<mml:mtable columnspacing="2.4pt" equalrows="false" columnlines="none" equalcolumns="false">
<mml:mtr>
<mml:mtd class="array" columnalign="left">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
</mml:mtd>
<mml:mtd class="array" columnalign="left">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">William</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd class="array" columnalign="left"/>
<mml:mtd class="array" columnalign="left">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">Kate</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math></inline-formula></td>
<td valign="top" align="left">1</td>
</tr>
<tr>
<td valign="top" align="left">4</td>
<td valign="top" align="left"><inline-formula><mml:math id="math106">
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mtext mathvariant="bold">William</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mtext mathvariant="bold">Harry</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">George</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Louis</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula></td>
<td valign="top" align="left"><inline-formula><mml:math id="math107">
<mml:mtable columnspacing="2.4pt" equalrows="false" columnlines="none" equalcolumns="false">
<mml:mtr>
<mml:mtd class="array" columnalign="left">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
</mml:mtd>
<mml:mtd class="array" columnalign="left">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd class="array" columnalign="left"/>
<mml:mtd class="array" columnalign="left">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">t</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">t</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">male</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd class="array" columnalign="left"/>
<mml:mtd class="array" columnalign="left">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">female</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd class="array" columnalign="left"/>
<mml:mtd class="array" columnalign="left">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">spouse</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">spouse</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math></inline-formula></td>
<td valign="top" align="left">3</td>
</tr>
<tr>
<td valign="top" align="left">5</td>
<td valign="top" align="left"><inline-formula><mml:math id="math108">
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mtext mathvariant="bold">Charles</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Diana</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Kate</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">William</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Harry</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">George</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Louis</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula></td>
<td valign="top" align="left"><inline-formula><mml:math id="math109">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula></td>
<td valign="top" align="left">2, 4</td>
</tr>
<tr>
<td valign="top" align="left">6</td>
<td valign="top" align="left"><inline-formula><mml:math id="math110">
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mtext mathvariant="bold">female</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mtext mathvariant="bold">male</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo>…</mml:mo>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi></mml:math></inline-formula></td>
<td valign="top" align="left"><inline-formula><mml:math id="math111">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mi>∅</mml:mi></mml:math></inline-formula></td>
<td valign="top" align="left">5</td>
</tr>
</tbody>
</table>
</table-wrap>
<fig id="x1-6005-3">
<label>Fig. 3.</label>
<caption>
<p>Venn diagram of the extensions of the 6 C-NNs of Charlotte, labelled by their numerical distance.</p>
</caption>
<graphic xlink:href="ds-4-ds200030-g003.jpg"/>
</fig>
<p>Table <xref rid="x1-6004-1">1</xref> lists the 6 C-NNs of Charlotte in the running example. Each row describes a concept of neighbours with its id, its extension, its intension, and its direct sub-concepts among the C-NNs. The bold part of extensions represent the <italic>proper extensions</italic> <inline-formula><mml:math id="math112">
<mml:mtext mathvariant="italic">proper</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> of C-NNs, i.e. the entities that do not appear in sub-concepts. The proper extensions of <inline-formula><mml:math id="math113">
<mml:mspace width="0.1667em"/>
<mml:mtext mathvariant="italic">C-NN</mml:mtext>
<mml:mspace width="0.1667em"/>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> define a partition over the set of entities <italic>E</italic>, where two entities are in the same proper extension if and only if they are at the same conceptual distance to entity <inline-formula><mml:math id="math114">
<mml:mi mathvariant="italic">Charlotte</mml:mi></mml:math></inline-formula>. The intension of the associated graph concept <inline-formula><mml:math id="math115">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> provides a symbolic representation of the similarity between every <inline-formula><mml:math id="math116">
<mml:msup>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>′</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mtext mathvariant="italic">proper</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math id="math117">
<mml:mi mathvariant="italic">Charlotte</mml:mi></mml:math></inline-formula>. For instance, concept <inline-formula><mml:math id="math118">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> says that <inline-formula><mml:math id="math119">
<mml:mi mathvariant="italic">Diana</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="math120">
<mml:mi mathvariant="italic">Kate</mml:mi></mml:math></inline-formula> have in common with <inline-formula><mml:math id="math121">
<mml:mi mathvariant="italic">Charlotte</mml:mi></mml:math></inline-formula> to be female persons. Figure <xref rid="x1-6005-3">3</xref> and the last column of Table <xref rid="x1-6004-1">1</xref> give the partial ordering between C-NNs: e.g., <inline-formula><mml:math id="math122">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>⩽</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. Smaller C-NNs contain entities that are closer to the chosen entity, here <inline-formula><mml:math id="math123">
<mml:mi mathvariant="italic">Charlotte</mml:mi></mml:math></inline-formula>. In particular, C-NNs <inline-formula><mml:math id="math124">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math125">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> contain the nearest neighbours of <inline-formula><mml:math id="math126">
<mml:mi mathvariant="italic">Charlotte</mml:mi></mml:math></inline-formula>. Although their numerical distance are the same (3), their intensions are very different: either being female or having William and Kate as parents.</p>
<p><italic>Discussion.</italic> Given that <inline-formula><mml:math id="math127">
<mml:mspace width="0.1667em"/>
<mml:mtext mathvariant="italic">C-NN</mml:mtext>
<mml:mspace width="0.1667em"/>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">e</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> partitions the set of entities, the number of C-NNs can only be smaller or equal to the number of entities, and in practice it is generally much smaller. This is interesting because, in comparison, the number of graph concepts is exponential in the number of entities in the worst case. Note that the search space of ILP approaches like AMIE+ is the set of queries, which is even larger than the set of all graph concepts. Computing the C-NNs for a given entity is therefore a much more tractable task than mining frequent patterns or learning rules, although the space of representations is the same. The pending questions that we study in this paper is whether those C-NNs are useful for inference, and how they compare to other approaches.</p>
<p>Compared to the use of numerical measures, like commonly done in k-NN approaches, C-NNs define a more subtle ordering of entities. First, because conceptual distances are only partially ordered, it can be that among two entities none is more similar than the other to the chosen entity <italic>e</italic>. This reflects the fact that there can be several ways to be similar to something, without necessarily a preferred one. For instance, who is most similar to Charlotte? Diana because she is also a female (C-NN <inline-formula><mml:math id="math128">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>) or George because he is also a son of William and Kate (C-NN <inline-formula><mml:math id="math129">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>)? Second, because conceptual distances partition the set of entities, it can be said that when two entities are at the exact same conceptual distance, they are undistinguishable in terms of similarity (ex. George and Louis in C-NN <inline-formula><mml:math id="math130">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>). Third, the concept intension provides an intelligible explanation of the similarity to the chosen entity.</p>
</sec>
<sec id="x1-7000-5.2">
<label>5.2.</label>
<title>Algorithmic and practical aspects</title>
<p>We here sketch the algorithmic and practical aspects of computing the set <inline-formula><mml:math id="math131">
<mml:mspace width="0.1667em"/>
<mml:mtext mathvariant="italic">C-NN</mml:mtext>
<mml:mspace width="0.1667em"/>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">e</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> of concepts of nearest neighbours of query entity <italic>e</italic> in a knowledge graph <italic>K</italic>. More details are available in [<xref ref-type="bibr" rid="ref008">8</xref>]. The naive approach would be to compute <inline-formula><mml:math id="math132">
<mml:mo stretchy="false">|</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi>
<mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> conceptual distances between <italic>e</italic> and the other entities. However, this is inefficient because in practice different entities will lead to the same concept or to concepts with overlapping intensions, and so some computations will be done again and again. Intuitively, our approach consists in computing the conceptual distances against clusters of entities instead of single entities. More concretely, our algorithm works by iteratively refining a partition <inline-formula><mml:math id="math133">
<mml:msub>
<mml:mrow>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo fence="true" stretchy="false">}</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> of the set of entities <italic>E</italic>, where each <inline-formula><mml:math id="math134">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is a cluster of entities, in order to get an increasingly accurate partition converging to the partition induced by the proper extensions of C-NNs.</p>
<p>Each cluster <inline-formula><mml:math id="math135">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is associated with a query <inline-formula><mml:math id="math136">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, and a set of candidate query elements <inline-formula><mml:math id="math137">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">H</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. The relationship to C-NNs is that when <inline-formula><mml:math id="math138">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">H</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is empty, the pair <inline-formula><mml:math id="math139">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is a C-NN (i.e. <inline-formula><mml:math id="math140">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mspace width="0.1667em"/>
<mml:mtext mathvariant="italic">C-NN</mml:mtext>
<mml:mspace width="0.1667em"/>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">e</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>), and <inline-formula><mml:math id="math141">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is the proper extension of <inline-formula><mml:math id="math142">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. When <inline-formula><mml:math id="math143">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">H</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is not empty, <inline-formula><mml:math id="math144">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is a generalization of concepts of neighbours, in the sense that either <inline-formula><mml:math id="math145">
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is the union of the extensions of several concepts of neighbours (lack of discrimination), or <inline-formula><mml:math id="math146">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is not necessarily the most specific query that matches all entities in <inline-formula><mml:math id="math147">
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> (lack of precision in the conceptual similarity). In that case, one gets overestimates of conceptual distances for some of the entities in <inline-formula><mml:math id="math148">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>.</p>
<fig id="x1-7001r-1">
<label>Algorithm 1</label>
<caption>
<p>Partitioning algorithm for entity <italic>e</italic> in knowledge graph <italic>K</italic></p>
</caption>
<graphic xlink:href="ds-4-ds200030-g004.jpg"/>
</fig>
<p>Algorithm <xref rid="x1-7001r-1">1</xref> details the partitioning algorithm. Initially, there is a single cluster <inline-formula><mml:math id="math149">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi></mml:math></inline-formula> with <inline-formula><mml:math id="math150">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> being the empty pattern, and <inline-formula><mml:math id="math151">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">H</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> being the <italic>description</italic> of <italic>e</italic>. The description of an entity <italic>e</italic> is a graph pattern that is obtained by extracting a subgraph around <italic>e</italic> and, for each entity <inline-formula><mml:math id="math152">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> in the subgraph, by replacing <inline-formula><mml:math id="math153">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> by a variable <inline-formula><mml:math id="math154">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, and by adding filter <inline-formula><mml:math id="math155">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">y</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. Here, we choose to extract the subgraph that contains all edges starting from <italic>e</italic> up to some depth.</p>
<p>Then at each iteration, any cluster <italic>S</italic> – with pattern <italic>P</italic> and set of candidate query elements <italic>H</italic> – is split in two clusters <inline-formula><mml:math id="math156">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> by using an element <inline-formula><mml:math id="math157">
<mml:mi mathvariant="italic">h</mml:mi>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">H</mml:mi></mml:math></inline-formula> as a discriminating feature. Element <italic>h</italic> must be chosen so that <inline-formula><mml:math id="math158">
<mml:mi mathvariant="italic">P</mml:mi>
<mml:mo>∪</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">h</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula> defines a connected pattern including variable <italic>x</italic>. Each addition of a query element therefore does one of the following: (a) add a filter constraint on a pattern variable, (b) add an edge between two pattern variables, or (c) add an edge from a pattern variable to a fresh variable. Many strategies are possible for choosing this element. In this work, we only consider two simple strategies:</p>
<list list-type="bullet">
<list-item>
<p><bold>Random</bold>: random choice among the valid elements;</p>
</list-item>
<list-item>
<p><bold>Ordered</bold>: choice of equality elements first, then triple patterns whose relation is the least frequently used in <italic>P</italic> (novelty).</p>
</list-item>
</list>
<p>The new clusters are defined as follows: 
<disp-formula>
<mml:math display="block" id="math159">
<mml:mtable columnspacing="2.4pt" equalrows="false" columnlines="none none none" equalcolumns="false">
<mml:mtr>
<mml:mtd class="array" columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">P</mml:mi>
<mml:mo>∪</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">h</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mspace width="2em"/>
</mml:mtd>
<mml:mtd class="array" columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mspace width="2em"/>
</mml:mtd>
<mml:mtd class="array" columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">S</mml:mi>
<mml:mo>∩</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mspace width="2em"/>
</mml:mtd>
<mml:mtd class="array" columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">H</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">H</mml:mi>
<mml:mo>∖</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">h</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd class="array" columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">P</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mspace width="2em"/>
</mml:mtd>
<mml:mtd class="array" columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">Q</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mspace width="2em"/>
</mml:mtd>
<mml:mtd class="array" columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">S</mml:mi>
<mml:mo>∖</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mspace width="2em"/>
</mml:mtd>
<mml:mtd class="array" columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">H</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">H</mml:mi>
<mml:mo>∖</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">h</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
The equations for <inline-formula><mml:math id="math160">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> ensure that after each split there is still a partition, possibly a more accurate one. The empty clusters (<inline-formula><mml:math id="math161">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi>∅</mml:mi></mml:math></inline-formula>) are removed from the partition. As a consequence, although the search space is the set of subgraphs of the description of <italic>e</italic>, which has a size exponential in the size of the description, the number of clusters remains below the number of entities at all time. In the running example, the initial cluster <inline-formula><mml:math id="math162">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> (the union of concepts <inline-formula><mml:math id="math163">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> to <inline-formula><mml:math id="math164">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>) is split with element <inline-formula><mml:math id="math165">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> into <inline-formula><mml:math id="math166">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math167">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mo>−</mml:mo>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. Then cluster <inline-formula><mml:math id="math168">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mo>−</mml:mo>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is split with element <inline-formula><mml:math id="math169">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> into <inline-formula><mml:math id="math170">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mo>−</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math171">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>6</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. Then cluster <inline-formula><mml:math id="math172">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
<mml:mo>−</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is split with element <inline-formula><mml:math id="math173">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">female</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> into <inline-formula><mml:math id="math174">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>2</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math175">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
<mml:mo>−</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. Next splits involve elements <inline-formula><mml:math id="math176">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> and <inline-formula><mml:math id="math177">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">William</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> on <inline-formula><mml:math id="math178">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>3</mml:mn>
<mml:mo>−</mml:mo>
<mml:mn>5</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula>.</p>
<p><italic>Handling of RDF schema (RDFS).</italic> The implementation takes into account the domain knowledge expressed as RDF Schema axioms [<xref ref-type="bibr" rid="ref016">16</xref>]. A special treatment is done for triples <inline-formula><mml:math id="math179">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mtext mathvariant="monospace">rdf:type</mml:mtext>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, where <inline-formula><mml:math id="math180">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is a class, i.e. an unary predicate from the logical point of view. Such an unary predicate is simulated by not replacing <inline-formula><mml:math id="math181">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> by a variable in the description of <italic>e</italic>. Taking inspiration from query relaxation [<xref ref-type="bibr" rid="ref017">17</xref>], the implementation also takes into account hierarchies of classes and properties, and domains and ranges of properties. For instance, this enables to find that two entities with respective type “horse” and “cat” have type “mammal” in common, even if it does not appear in their explicit description. A naive way to achieve this is to saturate entity descriptions with inferred triples. A more efficient way is to refine the above equation defining <inline-formula><mml:math id="math182">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">H</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <inline-formula><mml:math id="math183">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">H</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">H</mml:mi>
<mml:mo>∖</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">h</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo>∪</mml:mo>
<mml:mtext mathvariant="italic">relax</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">h</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, where <inline-formula><mml:math id="math184">
<mml:mtext mathvariant="italic">relax</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">h</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is a set of relaxations of <italic>h</italic> [<xref ref-type="bibr" rid="ref008">8</xref>]. For instance, the relaxation of a class is its set of superclasses.</p>
<p><italic>Termination and efficiency.</italic> The above algorithm terminates because the set <italic>H</italic> (or its saturation in case of RDFS axioms) decreases at each split. However, in the case of large descriptions or large knowledge graphs, it can still take a long time. Now, previous experiments [<xref ref-type="bibr" rid="ref008">8</xref>] show that most concepts are produced early, and that the rest of the time is spent at finding the last few concepts. Moreover, our algorithm is anytime because it can output a partition of entities at any time, and hence concepts of neighbours (possibly generalizations of them). It therefore makes sense to control runtime with a timeout parameter.</p>
<p>Actually, the above algorithm converges to an approximation of the C-NNs, in the sense that the conceptual distance may be still be an overestimate at full runtime for some entities. This is because graph patterns are constrained to be subsets of the description of <italic>e</italic>. In order to get exact results, the duplication of variables and their adjacent edges should be allowed, but this would considerably increase the search space.</p>
<p>Experiments on KGs with up to a million triples have shown that the algorithm can compute all C-NNs for descriptions of hundreds of edges in a matter of seconds or minutes. In contrast, query relaxation does not scale beyond 3 relaxation steps, which is insufficient to identify similar entities in most cases; and computing pairwise symbolic similarities does not scale to large numbers of entities. A key ingredient of the efficiency of the algorithm also lies in the notion of <italic>lazy join</italic> for the computation of answer sets of queries. In short, the principle is to compute <inline-formula><mml:math id="math185">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">S</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> from <italic>S</italic> in an incremental way (rather than computing <inline-formula><mml:math id="math186">
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> from scratch), and to avoid the enumeration of all matchings of <inline-formula><mml:math id="math187">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> by computing joins only as much as necessary to compute the set of query answers (see details in [<xref ref-type="bibr" rid="ref008">8</xref>]).</p>
<p>A last point to discuss is the scalability of C-NNs computation w.r.t. the KG size, i.e. what is the impact of doubling the number of entities. If we make the reasonable assumption that the new knowledge follows the same schema as the old knowledge (e.g., adding film descriptions to a film KG), then the impacts are that: (a) the query answers are two times larger, and (b) the number of C-NNs is somewhere between the same and the double, depending on the novelty of the new knowledge. As a consequence, if our objective is to compute a constant number of C-NNs for further inference, then it suffices to increase the timeout linearly with KG size.</p>
</sec>
</sec>
<sec id="x1-8000-6">
<label>6.</label>
<title>Link prediction</title>
<p>The problem of <italic>link prediction</italic> is to infer a missing entity in a triple <inline-formula><mml:math id="math188">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, i.e. either infer the tail from the head and the relation, or infer the head from the tail and the relation. Because of the symmetry of the two problems, we only describe here the inference of the tail entity. In the following, we therefore consider <inline-formula><mml:math id="math189">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math190">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as fixed (we avoid them in indices), and <inline-formula><mml:math id="math191">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as variable.</p>
<sec id="x1-9000-6.1">
<label>6.1.</label>
<title>C-NN-based inference</title>
<p>The principle of C-NN-based inference is to generate a ruleset for each concept of neighbours <inline-formula><mml:math id="math192">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mspace width="0.1667em"/>
<mml:mtext mathvariant="italic">C-NN</mml:mtext>
<mml:mspace width="0.1667em"/>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">K</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. Those rules are similar in nature to those of AMIE+ or AnyBURL except that only rules that are matched by the head entity <inline-formula><mml:math id="math193">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> are generated. Indeed, the bodies of generated rules are intensions of C-NNs, which are subsets of <inline-formula><mml:math id="math194">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>’s description. From the concept intension <inline-formula><mml:math id="math195">
<mml:mi mathvariant="italic">int</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, we generate two kinds of inference rules <italic>ρ</italic>:</p>
<list>
<list-item id="x1-9002x-1">
<label>(1)</label>
<p><bold>by-copy rules</bold>: <inline-formula><mml:math id="math196">
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo>:</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">→</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, for each <inline-formula><mml:math id="math197">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi></mml:math></inline-formula>;</p>
</list-item>
<list-item id="x1-9004x-2">
<label>(2)</label>
<p><bold>by-analogy rules</bold>: <inline-formula><mml:math id="math198">
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo>:</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">→</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, for each <inline-formula><mml:math id="math199">
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">Vars</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo stretchy="false">≠</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi></mml:math></inline-formula>.</p>
</list-item>
</list>
<p><italic>Inference by copy.</italic> The first kind of rules (<bold>by-copy rules</bold>) state that when an entity matches <inline-formula><mml:math id="math200">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>x</italic>, it is related to entity <inline-formula><mml:math id="math201">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> through relation <inline-formula><mml:math id="math202">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. As <inline-formula><mml:math id="math203">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> matches <inline-formula><mml:math id="math204">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>x</italic> by definition of concepts of neighbours, it can be inferred that <inline-formula><mml:math id="math205">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is related to <inline-formula><mml:math id="math206">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. In formula, the set of inferred entities is simply <inline-formula><mml:math id="math207">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula>. Of course, the strength of the inference depends on the support and confidence of the rule <italic>ρ</italic>, which are defined as follows. 
<disp-formula>
<mml:math display="block" id="math208">
<mml:mtable displaystyle="true">
<mml:mtr>
<mml:mtd>
<mml:mtext mathvariant="italic">supp</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em" stretchy="true">|</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">)</mml:mo>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em" stretchy="true">|</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mspace width="2em"/>
<mml:mtext mathvariant="italic">conf</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:mfrac>
<mml:mrow>
<mml:mo stretchy="false">|</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mo stretchy="false">|</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
<mml:mo>+</mml:mo>
<mml:mi mathvariant="italic">λ</mml:mi>
</mml:mrow>
</mml:mfrac>
</mml:mstyle>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
The support is defined as the number of entities that match <inline-formula><mml:math id="math209">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>x</italic> and are related to <inline-formula><mml:math id="math210">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> through <inline-formula><mml:math id="math211">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. The confidence is defined as the ratio of the support out of the number of entities that match <inline-formula><mml:math id="math212">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>x</italic>. Like this is done in AnyBURL [<xref ref-type="bibr" rid="ref023">23</xref>], we use a constant <inline-formula><mml:math id="math213">
<mml:mi mathvariant="italic">λ</mml:mi>
<mml:mo>⩾</mml:mo>
<mml:mn>0</mml:mn></mml:math></inline-formula> as a kind of additive Laplace smoothing, in order to favor rules with larger support. The principle of <italic>inference by copy</italic> is that the tail entities <inline-formula><mml:math id="math214">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> to be predicted for <inline-formula><mml:math id="math215">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> can be copied from the tail entities of <inline-formula><mml:math id="math216">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>’s neighbour entities. For example, if triple <inline-formula><mml:math id="math217">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Kate</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is missing in the above example graph, it can be inferred from some of her closest neighbours: “George and Louis are similar to Charlotte because they have William as a father, and their mother is Kate, so Charlotte’s mother could be Kate too” (support = 2, <inline-formula><mml:math id="math218">
<mml:mi mathvariant="normal">confidence</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>2</mml:mn>
<mml:mo mathvariant="normal" stretchy="false">/</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mn>3</mml:mn>
<mml:mo>+</mml:mo>
<mml:mi mathvariant="italic">λ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>).</p>
<p><italic>Inference by analogy.</italic> The second kind of rules (<bold>by-analogy rules</bold>) state that when a pair of entities match <inline-formula><mml:math id="math219">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>x</italic> and <italic>y</italic>, they are related through <inline-formula><mml:math id="math220">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. As <inline-formula><mml:math id="math221">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> matches <inline-formula><mml:math id="math222">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>x</italic> by definition of concepts of neighbours, it can be inferred that <inline-formula><mml:math id="math223">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is related through <inline-formula><mml:math id="math224">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> to any entity <inline-formula><mml:math id="math225">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> that matches <inline-formula><mml:math id="math226">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>y</italic> when <inline-formula><mml:math id="math227">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. In formula, the set of inferred entities is <inline-formula><mml:math id="math228">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. Like above, the strength of the inference depends on the support and confidence of the rule, which are defined as follows. 
<disp-formula>
<mml:math display="block" id="math229">
<mml:mtable displaystyle="true">
<mml:mtr>
<mml:mtd>
<mml:mtext mathvariant="italic">supp</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em" stretchy="true">|</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">(</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">)</mml:mo>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em" stretchy="true">|</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mspace width="2em"/>
<mml:mtext mathvariant="italic">conf</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo><mml:mstyle displaystyle="true">
<mml:mfrac>
<mml:mrow>
<mml:mo stretchy="false">|</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
</mml:mrow>
<mml:mrow>
<mml:mo stretchy="false">|</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
<mml:mo>+</mml:mo>
<mml:mi mathvariant="italic">λ</mml:mi>
</mml:mrow>
</mml:mfrac>
</mml:mstyle>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
The support is defined as the number of pairs of entities that match <inline-formula><mml:math id="math230">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>x</italic> and <italic>y</italic>, and that are related through <inline-formula><mml:math id="math231">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. The confidence is the ratio of the support out of the number of pairs of entities that match <inline-formula><mml:math id="math232">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>x</italic> and <italic>y</italic>, plus Laplace smoothing <italic>λ</italic>. The principle of <italic>inference by analogy</italic> here relies on the observation that “<inline-formula><mml:math id="math233">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is to <inline-formula><mml:math id="math234">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> as <italic>x</italic> is to <italic>y</italic>”. By observing that pairs <inline-formula><mml:math id="math235">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> that match pattern <inline-formula><mml:math id="math236">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> often satisfy <inline-formula><mml:math id="math237">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, one can predict the missing entity in <inline-formula><mml:math id="math238">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo>?</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> to be any entity <inline-formula><mml:math id="math239">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> such that pattern <inline-formula><mml:math id="math240">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is matched for <inline-formula><mml:math id="math241">
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math242">
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. For example, assume in the example graph that George, Charlotte, and Louis are only known to have father William, and that Kate is only known to be William’s spouse, i.e. triples <inline-formula><mml:math id="math243">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mi mathvariant="italic">George</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Louis</mml:mi>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Kate</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> are missing. Here, inference by copy for the parents of Charlotte would only produce Charles and Diana, using William and Harry as similar entities (see C-NN <inline-formula><mml:math id="math244">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>4</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> in Table <xref rid="x1-6004-1">1</xref>). The intension of the conceptual similarity of Charlotte with William and Harry is 
<disp-formula>
<mml:math display="block" id="math245">
<mml:mtable displaystyle="true" columnspacing="0pt 10pt 0pt 10pt 0pt 10pt 0pt 10pt 0pt 10pt">
<mml:mtr>
<mml:mtd columnalign="right"/>
<mml:mtd columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Q</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WH</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WH</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">m</mml:mi>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="right"/>
<mml:mtd columnalign="left">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WH</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">s</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">t</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">t</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">male</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd columnalign="right"/>
<mml:mtd columnalign="left">
<mml:mphantom>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WH</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo></mml:mphantom>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">spouse</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">spouse</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">gender</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">female</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
saying that “they have a father married to a woman”. From there the following by-analogy rule can be generated: <inline-formula><mml:math id="math246">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">WH</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">→</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. This rule states that “any female spouse (wife) of a male parent (father) is a parent”. Applying this rule to Charlotte (and equivalently to George and Louis) leads to the inference of the fact <inline-formula><mml:math id="math247">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Charlotte</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">parent</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Kate</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> because Kate is indeed the wife of William, who is the father of Charlotte. It is noteworthy here that Kate is predicted to be a parent although she never appears as a parent in the incomplete graph. This is not possible with inference by copy.</p>
<p><italic>Comparison with rules in other approaches.</italic> The main difference with other rule-based approaches is that we only generate rules that are specific to the entity <inline-formula><mml:math id="math248">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and relation <inline-formula><mml:math id="math249">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> for which predictions are to be made. Looking in more detail to the structure of rules, each approach has its own language bias. In AMIE+ [<xref ref-type="bibr" rid="ref011">11</xref>], only by-analogy rules are considered, and equality filters are excluded in most experiments because they make the number of rules explodes with the length of rules. They only retain <italic>closed</italic> rules, i.e. rules where each variable occurs at least twice. However, non-closed rules still have to be generated in order to reach all closed rules. Another difference is about rule measures. They use <italic>PCA confidence</italic>, a variation of classical confidence under the <italic>Partial Completeness Assumption (PCA)</italic>; and <italic>head coverage</italic>, which is a form of recall of the rule relative to the extension of relation <inline-formula><mml:math id="math250">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. In AnyBURL [<xref ref-type="bibr" rid="ref023">23</xref>], rule shapes are restricted to chains and cycles (including rule’s head), where rule’s head and equality filters cannot occur in the middle of a chain. The case of a chain with an equality filter on rule’s head is a subset of our by-copy rules. The case of a cycle is a subset of our by-analogy rules. AnyBURL supports a third kind of rule that is not covered in this work: <inline-formula><mml:math id="math251">
<mml:mi mathvariant="italic">P</mml:mi>
<mml:mo stretchy="false">→</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, where <inline-formula><mml:math id="math252">
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">Vars</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">P</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. Here, entities <inline-formula><mml:math id="math253">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> are predicted based on their own description, independently of entity <inline-formula><mml:math id="math254">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, which acts as a constant here. In RLvLR [<xref ref-type="bibr" rid="ref027">27</xref>], rules are equivalent to the cyclic rules of AnyBURL.</p>
</sec>
<sec id="x1-10000-6.2">
<label>6.2.</label>
<title>Aggregation of inferences</title>
<p>Given an incomplete triple <inline-formula><mml:math id="math255">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo>?</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, the output of a link prediction system is a ranking of entities <inline-formula><mml:math id="math256">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. Rankings of entities are evaluated with measures such as <inline-formula><mml:math id="math257">
<mml:mi mathvariant="normal">Hits</mml:mi>
<mml:mi>@</mml:mi>
<mml:mi mathvariant="italic">N</mml:mi></mml:math></inline-formula> (defined as 1 if the correct entity is among the first <italic>N</italic> entities, 0 otherwise), and MRR (Mean Reciprocal Rank, the inverse of the rank of the correct entity).</p>
<p>The question addressed in this section is how to aggregate all inferences presented in previous section into a global ranking. Indeed, the known entity <inline-formula><mml:math id="math258">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> leads to multiple concepts of neighbours, each concept of neighbours <inline-formula><mml:math id="math259">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> generates multiple rules, and each rule <italic>ρ</italic> infers a set <inline-formula><mml:math id="math260">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">E</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> of candidate entities <inline-formula><mml:math id="math261">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. The same candidate <inline-formula><mml:math id="math262">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> may be inferred by several rules, possibly generated from different concepts. In order to avoid the handling of too many rules, we exclude rules whose confidence is less than 1%, which is a very weak constraint. As a consequence, it may happen that some entities are not inferred by any rule, and hence that rankings do not include all entities of the KG. The missing entities are those for which there is not a single supporting evidence, and their rank is considered as infinite (<inline-formula><mml:math id="math263">
<mml:mi mathvariant="normal">Hits</mml:mi>
<mml:mi>@</mml:mi>
<mml:mi mathvariant="italic">N</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn></mml:math></inline-formula>, MRR = 0). The idea is to combine the measures of rules to give a score to each candidate <inline-formula><mml:math id="math264">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, in order to get a global ranking. In this paper, we consider two scores, which we reuse or adapt from previous work, and detail below:</p>
<list list-type="bullet">
<list-item>
<p><bold>Maximum Confidence (MC)</bold>: introduced in AnyBURL [<xref ref-type="bibr" rid="ref023">23</xref>];</p>
</list-item>
<list-item>
<p><bold>Dempster–Shafer (DS)</bold>: adapted from Denœux’s work on k-NN classification [<xref ref-type="bibr" rid="ref005">5</xref>].</p>
</list-item>
</list>
<p><italic>Maximum Confidence (MC) score.</italic> This score is quite simple, and was shown effective in AnyBURL’s work. The score of entity <inline-formula><mml:math id="math265">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is simply the list of the confidences of the rules that infer triple <inline-formula><mml:math id="math266">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, in decreasing order. This is a refinement of the score that was used in first experiments of AMIE, where the score was the maximum confidence among rules predicting <inline-formula><mml:math id="math267">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. Using a list of confidences instead of a single confidence allows for a finer ranking. Ranking of lists of confidences is done similarly to lexicographic ordering. Candidates are first compared with the first confidence. If their first confidence are equal, comparison is done with the second confidence, and so on. Then, candidates with longer lists are put first because they have more rules predicting them.</p>
<p><italic>Dempster–Shafer (DS) score.</italic> This score is inspired by the work of Denœux [<xref ref-type="bibr" rid="ref005">5</xref>], and adapted to our concepts of neighbours. Denoeux defines a k-NN classification rule based on Dempster–Shafer (DS) theory. Each <italic>k</italic>-nearest neighbour <inline-formula><mml:math id="math268">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> of an instance to be classified <italic>x</italic> is used as a piece of evidence that supports the fact that <italic>x</italic> belongs to the class <inline-formula><mml:math id="math269">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> of <inline-formula><mml:math id="math270">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. The degree of support is defined as a function of the distance between <italic>x</italic> and <inline-formula><mml:math id="math271">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">x</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, in such a way that the choice of <italic>k</italic> is less sensitive, so that large values of <italic>k</italic> can be chosen. DS theory enables to combine the <italic>k</italic> pieces of evidence into a global evidence, and to define a measure of <italic>belief</italic> for each class, which can be used as a score.</p>
<p>We adapt Denoeux’s work to the inference of <inline-formula><mml:math id="math272">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> in triple <inline-formula><mml:math id="math273">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo>?</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> in the following way. Each rule <italic>ρ</italic> that predicts <inline-formula><mml:math id="math274">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is used as a piece of evidence. The degree of support depends on the extensional distance <inline-formula><mml:math id="math275">
<mml:mtext mathvariant="italic">dist</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
<mml:mi mathvariant="italic">ext</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula> of the concept of neighbours <inline-formula><mml:math id="math276">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">δ</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> that generated the rule, and on the confidence of the rule. In order to have comparable pieces of evidence, we instantiate each by-analogy rule <inline-formula><mml:math id="math277">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">→</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> for each possible value of <italic>y</italic> into a by-copy rule: <inline-formula><mml:math id="math278">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">P</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">l</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">→</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. Indeed, by-analogy rules tend to be more general, and hence to have larger distances.</p>
<p>Because in KGs a head entity can be linked to several tail entities through the same relation, we consider a distinct classification problem for each candidate tail entity <inline-formula><mml:math id="math279">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo stretchy="false">∈</mml:mo>
<mml:mi mathvariant="italic">E</mml:mi></mml:math></inline-formula> with two classes <inline-formula><mml:math id="math280">
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup></mml:math></inline-formula> (<inline-formula><mml:math id="math281">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is a tail entity) and <inline-formula><mml:math id="math282">
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msubsup></mml:math></inline-formula> (<inline-formula><mml:math id="math283">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> is not a tail entity). For each candidate entity <inline-formula><mml:math id="math284">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and each rule <italic>ρ</italic> predicting <inline-formula><mml:math id="math285">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, the degree of support can therefore be formalized by defining a mass distribution <inline-formula><mml:math id="math286">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> over sets of classes as follows. 
<disp-formula>
<mml:math display="block" id="math287">
<mml:mtable displaystyle="true" columnalign="left">
<mml:mtr>
<mml:mtd>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">(</mml:mo>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">{</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">α</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mtext mathvariant="italic">conf</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mtext mathvariant="italic">dist</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mspace width="2em"/>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">(</mml:mo>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">{</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">(</mml:mo>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">{</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">α</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mtext mathvariant="italic">conf</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mtext mathvariant="italic">dist</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msup>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
<inline-formula><mml:math id="math288">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> represents the degree of belief for <inline-formula><mml:math id="math289">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> being the tail entity, while <inline-formula><mml:math id="math290">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> represents the degree of uncertainty. <inline-formula><mml:math id="math291">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo fence="true" stretchy="false">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> is set to 0 to reflect the OWA (Open World Assumption) of KGs according to which a missing fact is not considered as false. Constant <inline-formula><mml:math id="math292">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">α</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub></mml:math></inline-formula> determines the maximum degree of belief, which can be lower than 1 to reflect uncertainty about known triples (e.g. 0.95). The degree of belief decreases exponentially with distance. Finally, we make the degree of belief proportional to the confidence of inferring entity <inline-formula><mml:math id="math293">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> with rule <italic>ρ</italic>. In [<xref ref-type="bibr" rid="ref005">5</xref>], that confidence factor does not exist because it would be 1 for the class of the nearest neighbour, and 0 for every other class.</p>
<p>By applying Dempster–Shafer theory to combine the evidence from all rules <italic>ρ</italic> that predict entity <inline-formula><mml:math id="math294">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, we arrive at the following equation for the belief of each candidate tail entity <inline-formula><mml:math id="math295">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>. 
<disp-formula>
<mml:math display="block" id="math296">
<mml:mtable displaystyle="true">
<mml:mtr>
<mml:mtd>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">Bel</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">m</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">(</mml:mo>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">{</mml:mo>
<mml:msubsup>
<mml:mrow>
<mml:mi mathvariant="italic">c</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>1</mml:mn>
</mml:mrow>
</mml:msubsup>
<mml:mo fence="true" maxsize="1.19em" minsize="1.19em">}</mml:mo>
<mml:mo mathvariant="normal" fence="true" maxsize="1.19em" minsize="1.19em">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:munder>
<mml:mrow>
<mml:mstyle displaystyle="true">
<mml:mo largeop="true" movablelimits="false">∏</mml:mo></mml:mstyle>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">ρ</mml:mi>
</mml:mrow>
</mml:munder>
<mml:mn>1</mml:mn>
<mml:mo>−</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">α</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mtext mathvariant="italic">conf</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:msup>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mo>−</mml:mo>
<mml:mtext mathvariant="italic">dist</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mrow>
</mml:msup>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
We can use that belief as a score to rank all predicted entities by decreasing belief. The score used by AMIE+ is a special case of this score, where <inline-formula><mml:math id="math297">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">α</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>1</mml:mn></mml:math></inline-formula>, <inline-formula><mml:math id="math298">
<mml:mtext mathvariant="italic">dist</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">ρ</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>=</mml:mo>
<mml:mn>0</mml:mn></mml:math></inline-formula> for all rules, and PCA confidence is used instead of classical confidence.</p>
</sec>
<sec id="x1-11000-6.3">
<label>6.3.</label>
<title>Inference algorithm and explanations</title>
<p>Algorithm <xref rid="x1-11001r-2">2</xref> summarizes the full inference process in pseudo-code. Lines 1-3 initialises for each candidate entity the set of rules that infer it. Line 4 iterates over the C-NNs of entity <inline-formula><mml:math id="math299">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, after calling the partitioning algorithm (see Algorithm <xref rid="x1-7001r-1">1</xref>). Line 5 iterates over the by-copy rules generated from the current concept, and Line 11 iterates over the by-analogy rules. For each rule, if its confidence is above some threshold (0.01 in our experiments), it is added to the set of rules of all the entities inferred by the rule (Line 8 for by-copy rules, and Lines 14–16 for by-analogy rules). Lines 20–22 computes a score for each candidate entity by aggregating each set of rules into a single score. Finally, Line 23 simply returns a ranking of the candidate entities based on their computed score.</p>
<fig id="x1-11001r-2">
<label>Algorithm 2</label>
<caption>
<p>Inference and ranking of candidate entities <inline-formula><mml:math id="math300">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> for entity <inline-formula><mml:math id="math301">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and relation <inline-formula><mml:math id="math302">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> based on C-NNs</p>
</caption>
<graphic xlink:href="ds-4-ds200030-g005.jpg"/>
</fig>
<p>The algorithm can easily be extended to output for each inferred entity an explanation of why it was inferred. At Line 21, an explanation can be computed from the set of rules, in addition to the entity score. A simple form of explanation is to select the top-K rules according to the chosen score: confidence in the case of Maximum Confidence, and degree of belief in the case of Demster–Shafer. Each rule is directly interpretable in terms of entities and relationships (see Section <xref rid="x1-9000-6.1">6.1</xref>). Their readability can be improved by pretty-printing or graphical representation of the graph pattern. In our implementation, the graph patterns are displayed in a Turtle-like notation by doing a tree traversal starting from variable <italic>x</italic>, which for recall denotes entity <inline-formula><mml:math id="math303">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and its neighbours. A more advanced form of explanation could post-process rules by removing redundant elements, or by merging similar rules. This is left for future work.</p>
</sec>
</sec>
<sec id="x1-12000-7">
<label>7.</label>
<title>Experiments</title>
<p>We here report on experiments comparing our approach to other approaches on several standard benchmarks for link prediction. We first present the methodology, and study the impact on performance of the different strategies and hyper-parameters of our approach. Then we report performance results on benchmarks with an in-depth analysis. Finally, we discuss example inferences and explanations, and present a fine-grained comparison with AnyBURL. The companion page<xref ref-type="fn" rid="fn-2">2</xref><fn id="fn-2"><label><sup>2</sup></label>
<p>Companion page: <uri>http://www.irisa.fr/LIS/ferre/pub/link_prediction2020/</uri>.</p></fn> provides access to the source code, the datasets, and the experiment main results and logs.</p>
<sec id="x1-13000-7.1" sec-type="methods">
<label>7.1.</label>
<title>Methodology</title>
<table-wrap id="x1-13001-2">
<label>Table 2</label>
<caption>
<p>Statistics of datasets</p>
</caption>
<table frame="hsides" rules="groups">
<thead>
<tr>
<td valign="top" align="left">Dataset</td>
<td valign="top" align="center">Entities</td>
<td valign="top" align="center">Relations</td>
<td valign="top" align="center">Train edges</td>
<td valign="top" align="center">Valid. edges</td>
<td valign="top" align="center">Test edges</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">WN18</td>
<td valign="top" align="char" char=".">40943</td>
<td valign="top" align="char" char=".">18</td>
<td valign="top" align="char" char=".">141442</td>
<td valign="top" align="char" char=".">5000</td>
<td valign="top" align="char" char=".">5000</td>
</tr>
<tr>
<td valign="top" align="left">WN18RR</td>
<td valign="top" align="char" char=".">40559</td>
<td valign="top" align="char" char=".">11</td>
<td valign="top" align="char" char=".">86835</td>
<td valign="top" align="char" char=".">3034</td>
<td valign="top" align="char" char=".">3134</td>
</tr>
<tr>
<td valign="top" align="left">FB15k</td>
<td valign="top" align="char" char=".">14951</td>
<td valign="top" align="char" char=".">1345</td>
<td valign="top" align="char" char=".">483142</td>
<td valign="top" align="char" char=".">50000</td>
<td valign="top" align="char" char=".">59071</td>
</tr>
<tr>
<td valign="top" align="left">FB15k-237</td>
<td valign="top" align="char" char=".">15541</td>
<td valign="top" align="char" char=".">237</td>
<td valign="top" align="char" char=".">272115</td>
<td valign="top" align="char" char=".">17535</td>
<td valign="top" align="char" char=".">20466</td>
</tr>
<tr>
<td valign="top" align="left">Mondial</td>
<td valign="top" align="char" char=".">2473</td>
<td valign="top" align="char" char=".">20</td>
<td valign="top" align="char" char=".">8456</td>
<td valign="top" align="char" char=".">570</td>
<td valign="top" align="char" char=".">701</td>
</tr>
</tbody>
</table>
</table-wrap>
<p><italic>Datasets.</italic> We use four datasets that are used in many work to evaluate the link prediction task (WN18, WN18RR, FB15k, FB15k-237), plus an additional dataset that we derived from the Mondial dataset [<xref ref-type="bibr" rid="ref022">22</xref>]. Table <xref rid="x1-13001-2">2</xref> provides statistics about datasets (numbers of: entities, relations, train edges, validation edges, and test edges). WN18 and FB15k were introduced by Bordes <italic>et al.</italic> [<xref ref-type="bibr" rid="ref004">4</xref>] for link prediction evaluation. WN18 is derived from a subset of WordNet, and FB15k from FreeBase. In later work, it was observed that many test triples had their inverse in the training set (e.g., <italic>hypernym</italic> is the inverse of <italic>hyponym</italic> in WordNet), and could be solved with very simple rules (e.g., <inline-formula><mml:math id="math304">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">hypernym</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">→</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">hyponym</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>). More challenging datasets were introduced by removing from the validation and test sets all pairs of entities that occur in the training set. FB15k-237 was introduced by Toutanova and Chen [<xref ref-type="bibr" rid="ref030">30</xref>], and WN18RR was introduced by Dettmers <italic>et al.</italic> [<xref ref-type="bibr" rid="ref006">6</xref>].</p>
<p>We introduce Mondial as a subset of the Mondial database [<xref ref-type="bibr" rid="ref022">22</xref>], which contains facts about world geography. We simplified it to the task of link prediction by removing labelling edges and edges containing dates and numbers, and by unreifying n-ary relations into binary relations. Triples whose relation is <monospace>rdf:type</monospace> were also removed from the validation and test sets because they do not represent proper links between entities. The dataset is available from the companion page. It is smaller than other datasets but it makes it easier to interpret results, and we use it to study the impact of the different strategies and hyper-parameters without introducing a bias in our evaluation on the classical benchmarks.</p>
<p><italic>Task.</italic> We follow the same protocol as introduced in [<xref ref-type="bibr" rid="ref004">4</xref>], and followed by subsequent work. The task is to infer, for each test triple, the tail entity from the head and the relation, and also the head entity from the tail and the relation. We call <italic>test entity</italic> the known entity, and <italic>missing entity</italic> the entity to be inferred. We evaluate the performance of our approach by using the same three measures as in [<xref ref-type="bibr" rid="ref023">23</xref>]: MRR and <inline-formula><mml:math id="math305">
<mml:mi mathvariant="normal">Hits</mml:mi>
<mml:mi>@</mml:mi>
<mml:mo fence="true" stretchy="false">{</mml:mo>
<mml:mn>1</mml:mn>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mn>10</mml:mn>
<mml:mo fence="true" stretchy="false">}</mml:mo></mml:math></inline-formula> (given in percents in this paper). Like in previous work, we use filtered versions of those measures to reflect the fact that, for instance, there may be several correct tail entities for a 1–n relation (e.g., the relation from awards to nominees). For example, if the correct entity is at rank 7 but 2 out of the first 6 entities form triples that belong to the dataset (and are therefore considered as valid), then it is considered to be at rank 5.</p>
<p><italic>Method.</italic> Because our approach has no training phase we can use both train and validation datasets as examples for our instance-based inference. We consider a few alternative strategies: 
<list list-type="bullet">
<list-item>
<p>Random vs Ordered choice of a query element in the partitionning algorithm (see Section <xref rid="x1-7000-5.2">5.2</xref>);</p>
</list-item>
<list-item>
<p>by-copy vs by-analogy vs both kinds of inference rules (see Section <xref rid="x1-9000-6.1">6.1</xref>);</p>
</list-item>
<list-item>
<p>MC vs DS score for ranking inferred entities (see Section <xref rid="x1-10000-6.2">6.2</xref>).</p>
</list-item>
</list> 
Our approach has only three hyper-parameters (and no parameter to learn): the <italic>maximum depth</italic> of the description of the test entity, and two <italic>timeouts</italic>: one for the computation of C-NNs, and another one for the inference of an entity ranking. For the inference of a ranking of entities, we set <inline-formula><mml:math id="math306">
<mml:mi mathvariant="italic">λ</mml:mi>
<mml:mo>=</mml:mo>
<mml:mn>2</mml:mn></mml:math></inline-formula> in the definition of rule confidence, and <inline-formula><mml:math id="math307">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">α</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mn>0</mml:mn>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mn>0.95</mml:mn></mml:math></inline-formula> in the DS-score.</p>
<p>The implementation of our approach has been integrated to SEWELIS as an improvement of previous work on the guided edition of RDF graphs [<xref ref-type="bibr" rid="ref015">15</xref>]. A standalone program for link prediction is available from the companion page. We ran our experiments on Fedora 25, with CPU Intel(R) Core(TM) i7-6600U @ 2.60 GHz, and 16 GB DDR4 memory. So far, our implementation is simple and uses a single core, although our partitioning algorithm lends itself to parallelization. We have observed that in all our experiments the memory footprint, which includes the training and validation triples, remains under a few percents, i.e. a few hundreds MB. An alternative implementation<xref ref-type="fn" rid="fn-3">3</xref><fn id="fn-3"><label><sup>3</sup></label>
<p><uri>https://bitbucket.org/sebferre/conceptsofneighbours/</uri></p></fn> for the computation of C-NNs has recently been developed as a Java library on top of the Jena Framework,<xref ref-type="fn" rid="fn-4">4</xref><fn id="fn-4"><label><sup>4</sup></label>
<p><uri>https://jena.apache.org/</uri></p></fn> in order to facilitate their reuse in other applications.</p>
<p><italic>Baselines.</italic> We compare our approach to a number of historical or state-of-the-art latent-based approaches: DISTMULT [<xref ref-type="bibr" rid="ref031">31</xref>], ANALOGY [<xref ref-type="bibr" rid="ref021">21</xref>], KB_LR [<xref ref-type="bibr" rid="ref013">13</xref>], R-GCN+ [<xref ref-type="bibr" rid="ref029">29</xref>], ConvE [<xref ref-type="bibr" rid="ref006">6</xref>], ComplEx-N3 [<xref ref-type="bibr" rid="ref018">18</xref>], and CrossE [<xref ref-type="bibr" rid="ref033">33</xref>]. We do so by choosing the same tasks and measures as in previous work because it was not possible for us to run them ourselves (no access to a GPU), and also because it allows for a fairer comparison (e.g., choice of hyper-parameters by authors). We also compare our approach to rule-based approaches: AMIE+ [<xref ref-type="bibr" rid="ref011">11</xref>], RuleN [<xref ref-type="bibr" rid="ref024">24</xref>], and AnyBURL [<xref ref-type="bibr" rid="ref023">23</xref>]. Most performance results of the above approaches are reproduced from Meilicke <italic>et al.</italic> [<xref ref-type="bibr" rid="ref023">23</xref>] (see Section <xref rid="x1-15000-7.3">7.3</xref> for details). We add yet another baseline <italic>Freq</italic> that simply consists in ranking entities <inline-formula><mml:math id="math308">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> according to their decreasing frequency of usage in <inline-formula><mml:math id="math309">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> over the train + valid dataset, as defined by <inline-formula><mml:math id="math310">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">freq</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo>=</mml:mo>
<mml:mo stretchy="false">|</mml:mo>
<mml:mi mathvariant="italic">ans</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo stretchy="false">←</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo>=</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">|</mml:mo></mml:math></inline-formula>. It is independent of the test entity, and therefore acts as a default ranking.</p>
</sec>
<sec id="x1-14000-7.2">
<label>7.2.</label>
<title>Impact of strategies and hyper-parameters and consistency of results</title>
<table-wrap id="x1-14001-3">
<label>Table 3</label>
<caption>
<p>Comparing MRR on Mondial with 12 different strategies</p>
</caption>
<table frame="hsides" rules="groups">
<thead>
<tr>
<td valign="top" align="left"/>
<td valign="top" align="center" colspan="2">by-copy</td>
<td valign="top" align="center" colspan="2">by-analogy</td>
<td valign="top" align="center" colspan="2">by-copy+analogy</td>
</tr>
<tr>
<td valign="top"/>
<td valign="top" colspan="2"><hr/></td>
<td valign="top" colspan="2"><hr/></td>
<td valign="top" colspan="2"><hr/></td>
</tr>
<tr>
<td valign="top" align="left"/>
<td valign="top" align="center">MC</td>
<td valign="top" align="center">DS</td>
<td valign="top" align="center">MC</td>
<td valign="top" align="center">DS</td>
<td valign="top" align="center">MC</td>
<td valign="top" align="center">DS</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">Random</td>
<td valign="top" align="center">28.6</td>
<td valign="top" align="center">16.9</td>
<td valign="top" align="center">42.4</td>
<td valign="top" align="center">41.3</td>
<td valign="top" align="center"><bold>45.5</bold></td>
<td valign="top" align="center">44.2</td>
</tr>
<tr>
<td valign="top" align="left">Ordered</td>
<td valign="top" align="center">30.1</td>
<td valign="top" align="center">19.2</td>
<td valign="top" align="center">33.7</td>
<td valign="top" align="center">30.8</td>
<td valign="top" align="center">40.2</td>
<td valign="top" align="center">37.3</td>
</tr>
</tbody>
</table>
</table-wrap>
<p><italic>Impact of strategies.</italic> Table <xref rid="x1-14001-3">3</xref> compares the obtained MRR (in percents) on the Mondial dataset with different strategies. The timeout was set to 0.1 s for both C-NN computation and inference, and the maximum depth was set to 3. For recall, there are three axes composing the strategy: 
<list list-type="bullet">
<list-item>
<p>choice of a splitting element: <bold>Random</bold> vs <bold>Ordered</bold>;</p>
</list-item>
<list-item>
<p>kinds of inference rules: <bold>by-copy</bold> vs <bold>by-analogy</bold> vs both (<bold>by-copy</bold><inline-formula><mml:math id="math311">
<mml:mo mathvariant="bold">+</mml:mo></mml:math></inline-formula><bold>analogy</bold>);</p>
</list-item>
<list-item>
<p>aggregation of inferences: <bold>MC</bold> (max. confidence) vs <bold>DS</bold> (Dempster–Shafer).</p>
</list-item>
</list> 
This results in 12 different strategies, and Table <xref rid="x1-14001-3">3</xref> shows that the best performing combines <bold>Random</bold>, <bold>by-copy</bold><inline-formula><mml:math id="math312">
<mml:mo mathvariant="bold">+</mml:mo></mml:math></inline-formula><bold>analogy</bold>, and <bold>MC</bold>. Looking more in detail, we observe that combining both kinds of rules is always beneficial, as well as aggregating inferences with maximum confidence. However, <bold>Ordered</bold> element choice is better with <bold>by-copy</bold> rules, while <bold>Random</bold> element choice is better with <bold>by-analogy</bold> rules. We can also evaluate the importance of each axis by measuring the MRR decrease when replacing the best option by another. The most important options are in order: <bold>by-analogy</bold> rules (<inline-formula><mml:math id="math313">
<mml:mo>−</mml:mo>
<mml:mn>16.9</mml:mn></mml:math></inline-formula>), <bold>Random</bold> choice (<inline-formula><mml:math id="math314">
<mml:mo>−</mml:mo>
<mml:mn>5.3</mml:mn></mml:math></inline-formula>), <bold>by-copy</bold> rules (<inline-formula><mml:math id="math315">
<mml:mo>−</mml:mo>
<mml:mn>3.1</mml:mn></mml:math></inline-formula>), and finally <bold>MC</bold> aggregation (<inline-formula><mml:math id="math316">
<mml:mo>−</mml:mo>
<mml:mn>1.3</mml:mn></mml:math></inline-formula>). From now on, we only use the best performing strategy.</p>
<table-wrap id="x1-14002-4">
<label>Table 4</label>
<caption>
<p>Evolution of performance and internal parameters with timeout</p>
</caption>
<table frame="hsides" rules="groups">
<thead>
<tr>
<td valign="top" align="left">Timeout (s)  </td>
<td valign="top" align="center">Hits@1</td>
<td valign="top" align="center">Hits@10</td>
<td valign="top" align="center">MRR  </td>
<td valign="top" align="center">nb. concepts</td>
<td valign="top" align="center">nb. inferred</td>
<td valign="top" align="center">max. conf</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">0.001   </td>
<td valign="top" align="center">15.7</td>
<td valign="top" align="center">31.8</td>
<td valign="top" align="center">21.2   </td>
<td valign="top" align="char" char=".">3.7</td>
<td valign="top" align="center">103</td>
<td valign="top" align="center">0.20</td>
</tr>
<tr>
<td valign="top" align="left">0.01   </td>
<td valign="top" align="center">32.3</td>
<td valign="top" align="center">51.3</td>
<td valign="top" align="center">38.9   </td>
<td valign="top" align="char" char=".">11.9</td>
<td valign="top" align="center">211</td>
<td valign="top" align="center">0.42</td>
</tr>
<tr>
<td valign="top" align="left">0.1   </td>
<td valign="top" align="center">38.6</td>
<td valign="top" align="center">59.1</td>
<td valign="top" align="center">45.5   </td>
<td valign="top" align="char" char=".">35.0</td>
<td valign="top" align="center">311</td>
<td valign="top" align="center">0.57</td>
</tr>
<tr>
<td valign="top" align="left">1   </td>
<td valign="top" align="center">39.3</td>
<td valign="top" align="center">63.7</td>
<td valign="top" align="center">47.3   </td>
<td valign="top" align="char" char=".">89.2</td>
<td valign="top" align="center">351</td>
<td valign="top" align="center">0.66</td>
</tr>
</tbody>
</table>
</table-wrap>
<p><italic>Impact of timeout.</italic> Table <xref rid="x1-14002-4">4</xref> shows the evolution of a number of measures when timeout exponentially increases from 1 ms to 1 s. There are three performance measures (Hits@1, Hits@10, MRR), followed by three measures about the inference process, averaged over the test set: number of computed concepts of neighbours, number of inferred entities, and maximum confidence over all inferred entities. It can be observed that with only 1% of the largest timeout (timeout 0.01 s vs 1 s), the MRR is already at 82% of the larger MRR, and 60% of the inferred entities are obtained, despite the fact that only 13% of the concepts have been computed. This indicates that early approximations of concepts of neighbours are already informative. Furthermore, increasing the timeout and hence the number of concepts does not only improve MRR but also increases confidence in inferences as indicated by the steadily increasing maximum confidence.</p>
<p><italic>Impact of description depth.</italic> We have observed that increasing description depth beyond 2–3 makes almost no significant difference on performance measures, as well as on the number of inferred entities and on the maximum confidence. In the following, we therefore stick to a maximum description depth equal to 3.</p>
<fig id="x1-14003-4">
<label>Fig. 4.</label>
<caption>
<p>ROC curve of predicting Hits@1 correctness depending on maximum confidence threshold.</p>
</caption>
<graphic xlink:href="ds-4-ds200030-g006.jpg"/>
</fig>
<p><italic>Consistency of results.</italic> To evaluate the consistency of the results of our approach, we perform two analyses on the Mondial dataset (with timeout = 0.1s). First, we analyze the variability of the performance measures by splitting the test set 10-fold. We observe that the standard error across the 10 folds is very small for all measures: e.g., 0.5% for MRR, around 1% for Hits@1 and Hits@10, and 0.4% for maximum confidence.</p>
<p>Second, we analyze the relevance of the maximum confidence by measuring how predictive it is about the correctness of predictions. Figure <xref rid="x1-14003-4">4</xref> shows the ROC curve for the classification task that consists in predicting whether the top entity in the filtered ranking is correct based on the hypothesis that its associated maximum confidence is above a threshold varying from 0 to 1. For example, with threshold at 0.70, the true positive rate is at 73% while the false positive rate is at 16%. The shape of the curve, as well as its AUC (Area Under Curve) equal to 84%, demonstrate the relevance of the maximum confidence to estimate the validity of predictions. This comes in complement with interpretable explanations for inferred entities in the form of rules.</p>
</sec>
<sec id="x1-15000-7.3">
<label>7.3.</label>
<title>Results on benchmarks</title>
<table-wrap id="x1-15001-5">
<label>Table 5</label>
<caption>
<p>Comparison of performance results on WN18 and WN18RR</p>
</caption>
<table frame="hsides" rules="groups">
<thead>
<tr>
<td valign="top" align="left">Approach</td>
<td valign="top" align="left">Source</td>
<td valign="top" align="center" colspan="3">WN18</td>
<td valign="top" align="center" colspan="3">WN18RR</td>
</tr>
<tr>
<td valign="top"/>
<td valign="top"/>
<td valign="top" colspan="3"><hr/></td>
<td valign="top" colspan="3"><hr/></td>
</tr>
<tr>
<td valign="top" align="left"/>
<td valign="top" align="left"/>
<td valign="top" align="center">H@1</td>
<td valign="top" align="center">H@10</td>
<td valign="top" align="center">MRR</td>
<td valign="top" align="center">H@1</td>
<td valign="top" align="center">H@10</td>
<td valign="top" align="center">MRR</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left"><italic>Freq</italic></td>
<td valign="top" align="left"/>
<td valign="top" align="center">1.8</td>
<td valign="top" align="center">5.0</td>
<td valign="top" align="center">2.9</td>
<td valign="top" align="center">1.5</td>
<td valign="top" align="center">4.4</td>
<td valign="top" align="center">2.6</td>
</tr>
<tr>
<td valign="top" align="left" colspan="8"><italic>Latent-based</italic></td>
</tr>
<tr>
<td valign="top" align="left"> DISTMULT [<xref ref-type="bibr" rid="ref031">31</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref029">29</xref>]</td>
<td valign="top" align="center">70.1</td>
<td valign="top" align="center">94.3</td>
<td valign="top" align="center">81.3</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left"> ANALOGY [<xref ref-type="bibr" rid="ref021">21</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref021">21</xref>]</td>
<td valign="top" align="center">93.9</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">94.2</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left"> KB_LR [<xref ref-type="bibr" rid="ref013">13</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref013">13</xref>]</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">95.1</td>
<td valign="top" align="center">93.6</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left"> R-GCN+ [<xref ref-type="bibr" rid="ref029">29</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">69.7</td>
<td valign="top" align="center">96.4</td>
<td valign="top" align="center">81.9</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left"> ConvE [<xref ref-type="bibr" rid="ref006">6</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">93.5</td>
<td valign="top" align="center">95.5</td>
<td valign="top" align="center">94.2</td>
<td valign="top" align="center">39.0</td>
<td valign="top" align="center">48.0</td>
<td valign="top" align="center">46.0</td>
</tr>
<tr>
<td valign="top" align="left"> ComplEx-N3 [<xref ref-type="bibr" rid="ref018">18</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">96.0</td>
<td valign="top" align="center">95.0</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center"><bold>57.0</bold></td>
<td valign="top" align="center"><bold>48.0</bold></td>
</tr>
<tr>
<td valign="top" align="left"> CrossE [<xref ref-type="bibr" rid="ref033">33</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">74.1</td>
<td valign="top" align="center">95.0</td>
<td valign="top" align="center">83.0</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left" colspan="8"><italic>Rule-based</italic></td>
</tr>
<tr>
<td valign="top" align="left"> AMIE+ [<xref ref-type="bibr" rid="ref011">11</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">87.2</td>
<td valign="top" align="center">94.8</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">35.8</td>
<td valign="top" align="center">38.8</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left"> RuleN [<xref ref-type="bibr" rid="ref024">24</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">94.5</td>
<td valign="top" align="center">95.8</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">42.7</td>
<td valign="top" align="center">53.6</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left"> AnyBURL [<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">93.9</td>
<td valign="top" align="center">95.6</td>
<td valign="top" align="center">95.0</td>
<td valign="top" align="center"><bold>44.6</bold></td>
<td valign="top" align="center">55.5</td>
<td valign="top" align="center"><bold>48.0</bold></td>
</tr>
<tr>
<td valign="top" align="left"> C-NN (ours)</td>
<td valign="top" align="left"/>
<td valign="top" align="center"><bold>96.7</bold></td>
<td valign="top" align="center"><bold>97.2</bold></td>
<td valign="top" align="center"><bold>96.9</bold></td>
<td valign="top" align="center">44.4</td>
<td valign="top" align="center">51.9</td>
<td valign="top" align="center">46.9</td>
</tr>
<tr>
<td valign="top" align="left" colspan="2">C-NN − best other</td>
<td valign="top" align="center"><inline-formula><mml:math id="math317">
<mml:mo>+</mml:mo>
<mml:mn>2.2</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math318">
<mml:mo>+</mml:mo>
<mml:mn>0.8</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math319">
<mml:mo>+</mml:mo>
<mml:mn>1.9</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math320">
<mml:mo>−</mml:mo>
<mml:mn>0.2</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math321">
<mml:mo>−</mml:mo>
<mml:mn>5.1</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math322">
<mml:mo>−</mml:mo>
<mml:mn>1.1</mml:mn></mml:math></inline-formula></td>
</tr>
<tr>
<td valign="top" align="left" colspan="2">C-NN − best other rule-based</td>
<td valign="top" align="center"><inline-formula><mml:math id="math323">
<mml:mo>+</mml:mo>
<mml:mn>2.2</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math324">
<mml:mo>+</mml:mo>
<mml:mn>1.4</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math325">
<mml:mo>+</mml:mo>
<mml:mn>1.9</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math326">
<mml:mo>−</mml:mo>
<mml:mn>0.2</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math327">
<mml:mo>−</mml:mo>
<mml:mn>3.6</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math328">
<mml:mo>−</mml:mo>
<mml:mn>1.1</mml:mn></mml:math></inline-formula></td>
</tr>
</tbody>
</table>
</table-wrap>
<table-wrap id="x1-15002-6">
<label>Table 6</label>
<caption>
<p>Comparison of performance results on FB15k and FB15k-237</p>
</caption>
<table frame="hsides" rules="groups">
<thead>
<tr>
<td valign="top" align="left">Approach</td>
<td valign="top" align="left">Source</td>
<td valign="top" align="center" colspan="3">FB15k</td>
<td valign="top" align="center" colspan="3">FB15k-237</td>
</tr>
<tr>
<td valign="top"/>
<td valign="top"/>
<td valign="top" colspan="3"><hr/></td>
<td valign="top" colspan="3"><hr/></td>
</tr>
<tr>
<td valign="top" align="left"/>
<td valign="top" align="left"/>
<td valign="top" align="center">H@1</td>
<td valign="top" align="center">H@10</td>
<td valign="top" align="center">MRR</td>
<td valign="top" align="center">H@1</td>
<td valign="top" align="center">H@10</td>
<td valign="top" align="center">MRR</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left"><italic>Freq</italic></td>
<td valign="top" align="left"/>
<td valign="top" align="center">14.3</td>
<td valign="top" align="center">28.5</td>
<td valign="top" align="center">19.2</td>
<td valign="top" align="center">17.5</td>
<td valign="top" align="center">35.6</td>
<td valign="top" align="center">23.6</td>
</tr>
<tr>
<td valign="top" align="left" colspan="8"><italic>Latent-based</italic></td>
</tr>
<tr>
<td valign="top" align="left"> DISTMULT [<xref ref-type="bibr" rid="ref031">31</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref029">29</xref>]</td>
<td valign="top" align="center">52.2</td>
<td valign="top" align="center">81.4</td>
<td valign="top" align="center">63.4</td>
<td valign="top" align="center">10.6</td>
<td valign="top" align="center">37.6</td>
<td valign="top" align="center">19.1</td>
</tr>
<tr>
<td valign="top" align="left"> ANALOGY [<xref ref-type="bibr" rid="ref021">21</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref021">21</xref>]</td>
<td valign="top" align="center">64.6</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">72.5</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left"> KB_LR [<xref ref-type="bibr" rid="ref013">13</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref013">13</xref>]</td>
<td valign="top" align="center">74.2</td>
<td valign="top" align="center">87.3</td>
<td valign="top" align="center">79.0</td>
<td valign="top" align="center">22.0</td>
<td valign="top" align="center">48.2</td>
<td valign="top" align="center">30.6</td>
</tr>
<tr>
<td valign="top" align="left"> R-GCN+ [<xref ref-type="bibr" rid="ref029">29</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">60.1</td>
<td valign="top" align="center">84.2</td>
<td valign="top" align="center">69.6</td>
<td valign="top" align="center">15.1</td>
<td valign="top" align="center">41.7</td>
<td valign="top" align="center">24.9</td>
</tr>
<tr>
<td valign="top" align="left"> ConvE [<xref ref-type="bibr" rid="ref006">6</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">67.0</td>
<td valign="top" align="center">87.3</td>
<td valign="top" align="center">74.5</td>
<td valign="top" align="center"><bold>23.9</bold></td>
<td valign="top" align="center">49.1</td>
<td valign="top" align="center">31.6</td>
</tr>
<tr>
<td valign="top" align="left"> ComplEx-N3 [<xref ref-type="bibr" rid="ref018">18</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center"><bold>91.0</bold></td>
<td valign="top" align="center"><bold>86.0</bold></td>
<td valign="top" align="center">–</td>
<td valign="top" align="center"><bold>56.0</bold></td>
<td valign="top" align="center"><bold>37.0</bold></td>
</tr>
<tr>
<td valign="top" align="left"> CrossE [<xref ref-type="bibr" rid="ref033">33</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">63.4</td>
<td valign="top" align="center">87.5</td>
<td valign="top" align="center">72.8</td>
<td valign="top" align="center">21.1</td>
<td valign="top" align="center">47.4</td>
<td valign="top" align="center">29.9</td>
</tr>
<tr>
<td valign="top" align="left" colspan="8"><italic>Rule-based</italic></td>
</tr>
<tr>
<td valign="top" align="left"> AMIE+ [<xref ref-type="bibr" rid="ref011">11</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">64.7</td>
<td valign="top" align="center">85.8</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">17.4</td>
<td valign="top" align="center">40.9</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left"> RuleN [<xref ref-type="bibr" rid="ref024">24</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">77.2</td>
<td valign="top" align="center">87.0</td>
<td valign="top" align="center">–</td>
<td valign="top" align="center">18.2</td>
<td valign="top" align="center">42.0</td>
<td valign="top" align="center">–</td>
</tr>
<tr>
<td valign="top" align="left"> AnyBURL [<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="left">[<xref ref-type="bibr" rid="ref023">23</xref>]</td>
<td valign="top" align="center">80.4</td>
<td valign="top" align="center">89.0</td>
<td valign="top" align="center">83.0</td>
<td valign="top" align="center">23.0</td>
<td valign="top" align="center">47.9</td>
<td valign="top" align="center">30.0</td>
</tr>
<tr>
<td valign="top" align="left"> C-NN (ours)</td>
<td valign="top" align="left"/>
<td valign="top" align="center"><bold>82.7</bold></td>
<td valign="top" align="center">89.0</td>
<td valign="top" align="center">84.9</td>
<td valign="top" align="center">22.2</td>
<td valign="top" align="center">44.6</td>
<td valign="top" align="center">29.6</td>
</tr>
<tr>
<td valign="top" align="left" colspan="2">C-NN − best other</td>
<td valign="top" align="center"><inline-formula><mml:math id="math329">
<mml:mo>+</mml:mo>
<mml:mn>2.3</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math330">
<mml:mo>−</mml:mo>
<mml:mn>2.0</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math331">
<mml:mo>−</mml:mo>
<mml:mn>1.1</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math332">
<mml:mo>−</mml:mo>
<mml:mn>1.7</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math333">
<mml:mo>−</mml:mo>
<mml:mn>11.4</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math334">
<mml:mo>−</mml:mo>
<mml:mn>7.4</mml:mn></mml:math></inline-formula></td>
</tr>
<tr>
<td valign="top" align="left" colspan="2">C-NN − best other rule-based</td>
<td valign="top" align="center"><inline-formula><mml:math id="math335">
<mml:mo>+</mml:mo>
<mml:mn>2.3</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center">0.0</td>
<td valign="top" align="center"><inline-formula><mml:math id="math336">
<mml:mo>+</mml:mo>
<mml:mn>1.9</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math337">
<mml:mo>−</mml:mo>
<mml:mn>0.8</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math338">
<mml:mo>−</mml:mo>
<mml:mn>3.3</mml:mn></mml:math></inline-formula></td>
<td valign="top" align="center"><inline-formula><mml:math id="math339">
<mml:mo>−</mml:mo>
<mml:mn>0.4</mml:mn></mml:math></inline-formula></td>
</tr>
</tbody>
</table>
</table-wrap>
<p>Tables <xref rid="x1-15001-5">5</xref> and <xref rid="x1-15002-6">6</xref> compare the results of our approach (C-NN) to other approaches presented above as baselines on the four datasets WN18, WN18RR, FB15k, and FB15k-237. The baselines are organized in three groups: naive baseline <italic>Freq</italic>, latent-based approaches, and rule-based approaches. In each group, approaches are sorted by publication year. The <italic>source</italic> indicates which paper the results are taken from. The results for AnyBURL are those where 1000 s (largest available time) are allocated to the computation of rules. In the results of C-NN, the timeouts (computation of concepts + inference) are 1 + 1 s for WN datasets, and 1.5 + 0.5 s for FB datasets. The output logs of C-NN predictions and explanations are available from the companion page.</p>
<p>ComplEx-N3 clearly outperforms other approaches on all datasets except WN18 where C-NN outperforms other approaches on the three measures. C-NN comes second on FB15k, and remains close to the best approaches on WN18RR. On FB15k-237, the MRR delta is <inline-formula><mml:math id="math340">
<mml:mo>−</mml:mo>
<mml:mn>7.4</mml:mn></mml:math></inline-formula> with ComplEx-N3, but only <inline-formula><mml:math id="math341">
<mml:mo>−</mml:mo>
<mml:mn>0.4</mml:mn></mml:math></inline-formula> with AnyBURL, the best rule-based approach. It is noteworthy that C-NN is competitive with AnyBURL because, whereas AnyBURL rules are computed in a supervised manner (knowing the target relation <inline-formula><mml:math id="math342">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">r</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">k</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>), C-NN concepts are computed in an unsupervised manner (i.e, only knowing the source entity <inline-formula><mml:math id="math343">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>). This implies that the concepts of neighbours of an entity can be computed once, and used for many different inference tasks, e.g. predicting links for several target relations.</p>
<p>Looking at the <italic>Freq</italic> baseline, it becomes visible how FB15k-237 is difficult because performance improvements over <italic>Freq</italic> are relatively small while they are huge on other datasets.</p>
</sec>
<sec id="x1-16000-7.4">
<label>7.4.</label>
<title>In-depth analysis of results</title>
<p>In this section, we refine the performance evaluation of our approach by analysing results w.r.t two criteria: (a) the kind of rule (by-copy vs by-analogy) that inferred the rank-1 predictions, (b) the characteristics of the relation to be predicted.</p>
<table-wrap id="x1-16001-7">
<label>Table 7</label>
<caption>
<p>Split of test sets depending on the kind of inference rule (by-copy vs by-analogy)</p>
</caption>
<table frame="hsides" rules="groups">
<thead>
<tr>
<td valign="top" align="left">Measure</td>
<td valign="top" align="center" colspan="2">WN18</td>
<td valign="top" align="center" colspan="2">WN18RR</td>
<td valign="top" align="center" colspan="2">FB15k</td>
<td valign="top" align="center" colspan="2">FB15k-237</td>
</tr>
<tr>
<td valign="top"/>
<td valign="top" colspan="2"><hr/></td>
<td valign="top" colspan="2"><hr/></td>
<td valign="top" colspan="2"><hr/></td>
<td valign="top" colspan="2"><hr/></td>
</tr>
<tr>
<td valign="top" align="left"/>
<td valign="top" align="center">by-c</td>
<td valign="top" align="center">by-a</td>
<td valign="top" align="center">by-c</td>
<td valign="top" align="center">by-a</td>
<td valign="top" align="center">by-c</td>
<td valign="top" align="center">by-a</td>
<td valign="top" align="center">by-c</td>
<td valign="top" align="center">by-a</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">Percent</td>
<td valign="top" align="center">2%</td>
<td valign="top" align="center">98%</td>
<td valign="top" align="center">38%</td>
<td valign="top" align="center">57%</td>
<td valign="top" align="center">14%</td>
<td valign="top" align="center">85%</td>
<td valign="top" align="center">73%</td>
<td valign="top" align="center">25%</td>
</tr>
<tr>
<td valign="top" align="left">Hits@1</td>
<td valign="top" align="center">15.0</td>
<td valign="top" align="center">98.7</td>
<td valign="top" align="center">15.2</td>
<td valign="top" align="center">67.8</td>
<td valign="top" align="center">37.0</td>
<td valign="top" align="center">91.0</td>
<td valign="top" align="center">26.2</td>
<td valign="top" align="center">12.2</td>
</tr>
<tr>
<td valign="top" align="left">Hits@10</td>
<td valign="top" align="center">34.4</td>
<td valign="top" align="center">98.8</td>
<td valign="top" align="center">29.4</td>
<td valign="top" align="center">71.6</td>
<td valign="top" align="center">63.5</td>
<td valign="top" align="center">94.2</td>
<td valign="top" align="center">49.9</td>
<td valign="top" align="center">32.3</td>
</tr>
<tr>
<td valign="top" align="left">MRR</td>
<td valign="top" align="center">22.0</td>
<td valign="top" align="center">98.7</td>
<td valign="top" align="center">19.9</td>
<td valign="top" align="center">69.1</td>
<td valign="top" align="center">47.0</td>
<td valign="top" align="center">92.1</td>
<td valign="top" align="center">34.1</td>
<td valign="top" align="center">18.7</td>
</tr>
<tr>
<td valign="top" align="left">max. conf</td>
<td valign="top" align="center">0.24</td>
<td valign="top" align="center">0.96</td>
<td valign="top" align="center">0.28</td>
<td valign="top" align="center">0.70</td>
<td valign="top" align="center">0.60</td>
<td valign="top" align="center">0.88</td>
<td valign="top" align="center">0.61</td>
<td valign="top" align="center">0.66</td>
</tr>
</tbody>
</table>
</table-wrap>
<p><italic>Prediction by-copy vs by-analogy.</italic> We here analyze predictions according to the kind of the <italic>best rule</italic>, i.e. the rule with highest confidence, which contributed to decide the first entity in the generated ranking. For recall, there are two kinds of rules: by-copy rules and by-analogy rules (see Section <xref rid="x1-9000-6.1">6.1</xref>). Table <xref rid="x1-16001-7">7</xref> shows the performance measures, and maximum confidence, on two subsets of the test set for each dataset, depending on the kind of the best rule. Line “percent” gives the relative size of those subsets. The two percentages may not sum up to 100% because for some test cases, no prediction could be made: e.g., all predicted entities are already known to hold, and are therefore filtered out.</p>
<p>The balance between by-copy and by-analogy can be explained by the nature of each dataset. In WN18 and FB15k it is well known that most test triples can be inferred from an inverse triple, which is well captured with by-analogy rules: e.g., <inline-formula><mml:math id="math344">
<mml:mi mathvariant="italic">hypernym</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">→</mml:mo>
<mml:mi mathvariant="italic">hyponym</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>. In FB15k-237, all inverse triples have been removed, and for many relations, some candidate entities are much more frequent than others: e.g., US nationality for people. Those frequent entities are easily inferred with by-copy rules. In WN18RR, by-analogy rules remain dominant for two reasons. First, inverse relations have been removed (e.g., <inline-formula><mml:math id="math345">
<mml:mi mathvariant="italic">hyponym</mml:mi></mml:math></inline-formula> as inverse of <inline-formula><mml:math id="math346">
<mml:mi mathvariant="italic">hypernym</mml:mi></mml:math></inline-formula>), but other inverse triples have been retained. In particular, symmetric relations such as <italic>similar_to</italic> and <italic>derivationally_related_form</italic> are still present, and account for about one third of test triples. Second, there are much less situations like “US nationality”, where a single word would dominate in a relation. The performance measures (Hits@1, Hits@10, MRR) are consistent with the balance between by-copy and by-analogy: measures are better for the most frequent kind of rule. However, it appears that by-analogy rules always have a higher confidence on average. We hypothesize that this is because by-analogy inference relies on the similarity with not only entity <inline-formula><mml:math id="math347">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> but with pair of entities <inline-formula><mml:math id="math348">
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula>, and involves an explicit relationship between <inline-formula><mml:math id="math349">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">i</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula> and <inline-formula><mml:math id="math350">
<mml:msub>
<mml:mrow>
<mml:mi mathvariant="italic">e</mml:mi>
</mml:mrow>
<mml:mrow>
<mml:mi mathvariant="italic">j</mml:mi>
</mml:mrow>
</mml:msub></mml:math></inline-formula>, expressed as a graph pattern.</p>
<fig id="x1-16002-5">
<label>Fig. 5.</label>
<caption>
<p>MRR as a function of relation degree. Bubble sizes are proportional to relation frequency.</p>
</caption>
<graphic xlink:href="ds-4-ds200030-g007.jpg"/>
</fig>
<p><italic>Results depending on relation characteristics.</italic> Relations are not all alike in knowledge graphs. They vary in frequency, and whether they are functional or multi-valued. We here define the <italic>frequency</italic> of a relation <italic>r</italic> as the number of test triples using it; and its <italic>degree</italic> as the average number of tail entities per head entity in the training set. When the degree equals (or is closed to) 1, the relation is said <italic>functional</italic>, otherwise it is said <italic>multi-valued</italic>. As the benchmarks imply to predict both the tail from the head, and the head from the tail, we also consider inverse relations. Their frequency is the same, and their degree is the average number of head entities per tail entity. The degree of the inverse relation is unrelated to the degree of the relation, and all combinations are possible, i.e. 1–1, n–1, 1–n, and n–n relations.</p>
<p>Figure <xref rid="x1-16002-5">5</xref> shows a bubble plot of the 224 relations and their inverses, which are found in the test set of FB15k-237, the most challenging dataset. Each bubble is positioned according to its degree (ranging from 1 to 4000), and to the MRR of its predictions (ranging from 0 to 1). The bubble size reflects the frequency of the relation, and hence its weight in the global performance measures. Several observations can be made. First, the relations cover a wide range of frequencies and degrees, and there are no obvious correlation between those two dimensions. Second, there is a clear tendency that the higher the degree, the lower the MRR, i.e. multi-valued relations are harder to predict than functional relations. However, many relations stand under and above this tendency. Some relations have a low MRR despite a low degree (e.g., <italic>place of birth</italic>); and some relation succeeds to have a high MRR despite degrees up to 50 (e.g., inverse of <italic>food nutrient</italic> with degree = 15). Examples of frequent relations with high MRR are: <italic>people nationality</italic> (degree = 1.1, MRR = 79.3), <italic>people gender</italic> (degree = 1, MRR = 90.4), <italic>topic webpage category</italic> (degree = 1, MRR = 100), <italic>marriage type of union</italic> (degree = 1.1, MRR = 100), <italic>award winners ceremony</italic> (degree = 12, MRR = 71.4), and its inverse (degree = 22, MRR = 70.1).</p>
<p><italic>Scalability w.r.t. the size of the knowledge graph.</italic> The scalability of the C-NN approach is difficult to evaluate because the runtime is determined by the user-given timeouts. It can only be evaluated by comparing the prediction performance for KGs of different sizes. However, the prediction performance cannot be compared easily between different datasets because inference difficulty varies from one dataset to another. Even starting from one large KG and using subgraphs of different sizes is tricky if one wants to keep the same inference difficulty. Synthetic KGs may be useful for benchmarking the scalability of query or reasoning engines [<xref ref-type="bibr" rid="ref003">3</xref>,<xref ref-type="bibr" rid="ref014">14</xref>] but they may not have enough regularities for the task of link prediction. We propose the following methodology to give some hint on the scalability of our approach. We consider an additional link prediction dataset, YAGO03-10 [<xref ref-type="bibr" rid="ref006">6</xref>], that is similar in contents to the Freebase datasets but with about 10 times more entities (123K). According to our discussion at the end of Section <xref rid="x1-5000-5">5</xref>, the timeout should increase linearly with the number of entities. We therefore ran our approach with timeouts 15 + 5 s, and we checked if C-NN’s performance remains competitive with AnyBURL’s performance on YAGO3 (available in [<xref ref-type="bibr" rid="ref023">23</xref>], with timeout = 1000 s like above). Estimating on 10% of test instances (out of 10000), we obtain the following results.</p>
<table-wrap>
<table frame="hsides" rules="groups">
<thead>
<tr>
<td valign="top" align="left">Approach</td>
<td valign="top" align="center">H@1</td>
<td valign="top" align="center">H@10</td>
<td valign="top" align="center">MRR</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">AnyBURL</td>
<td valign="top" align="center">42.9</td>
<td valign="top" align="center">63.9</td>
<td valign="top" align="center">49</td>
</tr>
<tr>
<td valign="top" align="left">C-NN</td>
<td valign="top" align="center">42.4 ± 1.5</td>
<td valign="top" align="center">67.8 ± 1.4</td>
<td valign="top" align="center">51.2 ± 1.4</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>The differences are comparable with those of other datasets, hence supporting the linear scaling rule.</p>
<p>Now, the consequence of that linear scaling is that our approach cannot yet be applied in practice to very large KGs with millions of entities, like DBpedia or Wikidata, as the timeout per inference would have to be increased to non-practical values (about 15 min on DBpedia). In order to achieve this goal, it will be necessary to compute more concepts of neighbours in less time. Optimization will not be enough, and it will be necessary to find robust sampling strategies: to compute C-NNs on a representative subset of entities, to select the relevant part of entity descriptions in the partitioning process, and to estimate the confidence of rules without computing all pattern matchings.</p>
</sec>
<sec id="x1-17000-7.5">
<label>7.5.</label>
<title>Example inferences and explanations</title>
<p>In this section, we look at example inferences in order to discuss the explainability of our approach. Note that further work is required to make explanations easier to use, and that our objective is here to show the potential of our approach, and the limits of the current implementation. We here consider inferences for the Mondial datasets because they are easier to read. Indeed, the Freebase and WordNet datasets use opaque identifiers for entities (e.g., 03735637 in WordNet, 05h43ls in Freebase), while Mondial uses clear URIs (e.g., <uri>http://www.semwebtech.org/mondial/10/country/ANG</uri> for Angola). In the next section we discuss inferences on FB15k-237 in comparison to AnyBURL. We describe below four correct and one incorrect inferences. Those are not cherry-picked. They are simply the top five inferences in the experiment log available on the companion page (only considering 0.1 + 0.1 s timeout). In the following, support and confidence measures are abbreviated as ‘supp’ and ‘conf’. 
<list>
<list-item id="x1-17002x-1">
<label>(1)</label>
<p>The (missing) neighbors countries of Angola are correctly predicted to be Zambia and Zaire (conf = 0.91) by the following by-analogy rule (supp = 85, conf = 0.91). Subsequent predictions have much lower confidences: South Sudan and Cameroon (conf = 0.41). 
<disp-formula>
<mml:math display="block" id="math351">
<mml:mtable displaystyle="true" columnalign="left">
<mml:mtr>
<mml:mtd>
<mml:mi mathvariant="italic">ethnicGroup</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">locatedIn</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">flowsInto</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">locatedInWater</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">w</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">neighbor</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mspace width="1em"/>
<mml:mo stretchy="false">→</mml:mo>
<mml:mi mathvariant="italic">neighbor</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
This rule is a specialization of the rule <inline-formula><mml:math id="math352">
<mml:mi mathvariant="italic">neighbor</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">→</mml:mo>
<mml:mi mathvariant="italic">neighbor</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo></mml:math></inline-formula> saying that neighborhood is a symmetric relationship. Because of our instance-based approach, our rules tend to be overly specific compared to rule mining approaches. Note that the above rule still covers 85 countries (out of 244). However, although this is let for future work, it would be relatively easy to wipe out the superfluous atoms of the rule by checking which atoms can be removed without decreasing the rule confidence.</p>
</list-item>
<list-item id="x1-17004x-2">
<label>(2)</label>
<p>Sweden is correctly predicted to be encompassed in Europe by the following by-value rule (supp = 25, conf = 0.56). The subsequent prediction is America (conf = 0.36). 
<disp-formula>
<mml:math display="block" id="math353">
<mml:mtable displaystyle="true" columnalign="left">
<mml:mtr>
<mml:mtd>
<mml:mi mathvariant="italic">language</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">neighbor</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">locatedIn</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Lake</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">locatedIn</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Mountain</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mspace width="1em"/>
<mml:mo stretchy="false">→</mml:mo>
<mml:mi mathvariant="italic">encompassed</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Europe</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
This rule says that a country <italic>x</italic> is in Europe if it has a language and a neighbor country, and if it contains a lake and a mountain. Obviously, this is not a generally valid rule, as its confidence shows, but its inferences are still valid in the majority of cases. It is interesting to see that our approach can not only make logical inferences like in the first example, but also statistical inferences based on <italic>best guess</italic> rules.</p>
</list-item>
<list-item id="x1-17006x-3">
<label>(3)</label>
<p>Islay is correctly predicted to belong to Inner Hebrides (conf = 0.34 0.34 0.31) by the following top-1 by-analogy rule (supp = 54, conf = 0.34), and two other rules (not shown, conf = 0.34 and conf = 0.31). There are five subsequent predictions (all UK islands) with same first and second confidences but lower third confidence, then Canares (conf = 0.29), Lesser Antilles (conf = 0.27). 
<disp-formula>
<mml:math display="block" id="math354">
<mml:mtable displaystyle="true" columnalign="left">
<mml:mtr>
<mml:mtd>
<mml:mi mathvariant="italic">locatedIn</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">locatedIn</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">belongToIslands</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">locatedInWater</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mspace width="2em"/>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo>=</mml:mo>
<mml:mi mathvariant="italic">AtlanticOcean</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mspace width="1em"/>
<mml:mo stretchy="false">→</mml:mo>
<mml:mi mathvariant="italic">belongToIslands</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
This rules says that an island <italic>x</italic> belongs to islands <italic>y</italic> if <italic>x</italic> shares a location (here, UK) with another island <italic>z</italic> that belongs to <italic>y</italic>, and <italic>x</italic> is located in the Atlantic Ocean. Apart from the specialization to the Atlantic Ocean, this rules makes sense because if two islands are located in a same place, e.g. a same country, there is a good chance that they belong to the same islands. However, this is not precise enough, like here where UK islands belong to 5 different islands (Inner Hebrides, Outer Hebrides, Shetlands, …). The top-3 rules are required to discriminate between them. This demonstrates the value of the maximum confidence measure that makes use of all rule confidences in ranking. Note that without the additional rules, the correct entity would still be at a small rank, here 5th in the worst case.</p>
</list-item>
<list-item id="x1-17008x-4">
<label>(4)</label>
<p>Matternhorn is correctly predicted to be located in Switzerland (conf = 0.42 0.36) by the following top-1 by-analogy rule (supp = 153, confs = 0.42) and another rule (not shown, conf = 0.36). Subsequent predictions are France (conf = 0.42 0.27), Austria (conf = 0.42 0.14), Germany (conf = 0.42 0.11). 
<disp-formula>
<mml:math display="block" id="math355">
<mml:mtable displaystyle="true">
<mml:mtr>
<mml:mtd>
<mml:mi mathvariant="italic">Mountain</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">inMountains</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">inMountains</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">locatedIn</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo stretchy="false">→</mml:mo>
<mml:mi mathvariant="italic">locatedIn</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo>.</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
This rule is similar to the previous one. In short, it says that two mountains that belong to the same mountain range tends to be located in the same place (typically a country). The confidence is 0.42 so that there are many exceptions but the support is high (supp = 153). Similarly to the previous example, an additional rule was required to discriminate with neighbor countries.</p>
</list-item>
<list-item id="x1-17010x-5">
<label>(5)</label>
<p>The Baltic sea is <italic>incorrectly</italic> predicted to have an inflow from Goetaaelv (conf = 0.33) by the following by-copy rule (supp = 1, conf = 0.33), instead of the expected Narva and Dalaelv (conf = 0.03), which are predicted at ranks 274 and 302. Goetaaelv flows into a neighbor sea (Kattegat) of the Baltic sea but not in the Baltic sea proper. 
<disp-formula>
<mml:math display="block" id="math356">
<mml:mtable displaystyle="true" columnalign="left">
<mml:mtr>
<mml:mtd>
<mml:mi mathvariant="italic">locatedIn</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">neighbor</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">y</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">z</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">locatedInWater</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">u</mml:mi>
<mml:mo>=</mml:mo>
<mml:mtext mathvariant="italic">Seeland</mml:mtext>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mspace width="2em"/>
<mml:mi mathvariant="italic">locatedInWater</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">Island</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">v</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mtd>
</mml:mtr>
<mml:mtr>
<mml:mtd>
<mml:mspace width="1em"/>
<mml:mo stretchy="false">→</mml:mo>
<mml:mi mathvariant="italic">flowsInto</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">(</mml:mo>
<mml:mi mathvariant="italic">Goetaaelv</mml:mi>
<mml:mo mathvariant="normal">,</mml:mo>
<mml:mi mathvariant="italic">x</mml:mi>
<mml:mo mathvariant="normal" fence="true" stretchy="false">)</mml:mo>
</mml:mtd>
</mml:mtr>
</mml:mtable></mml:math>
</disp-formula> 
This rule is very specific, and its support is only 1. It is clear that such an explanation should not be trusted blindly. Laplace smoothing helped lower its confidence from 1 downto 0.33 but no better rule was found here. Note however that rules with low support can still be useful sometimes when they retrieve very similar entities from which valid inferences can be drawn.</p>
</list-item>
</list> 
In conclusion, the current output of our implementation already contains a lot of information to understand the top prediction, and to assess its strength. It is important to see the given rules as statistical rules (similar to association rules [<xref ref-type="bibr" rid="ref001">1</xref>]), rather than as logical rules that are either true or false, and to take into account the associated measures such as support and confidence. The above examples call for an interactive user interface in order to let users access more than the top-1 inference rule of the top-1 prediction, on demand.</p>
</sec>
<sec id="x1-18000-7.6">
<label>7.6.</label>
<title>Detailed comparison with AnyBURL</title>
<p>In this section, we detail the comparison with predictions made by AnyBURL.<xref ref-type="fn" rid="fn-5">5</xref><fn id="fn-5"><label><sup>5</sup></label>
<p>Detailed predictions for state-of-the-art latent-based approaches are not available, and specific hardware (GPUs) is required to run them in a reasonable amount of time.</p></fn> Indeed, AnyBURL is the state-of-the-art among rule-based approaches. The main question we answer here is: How predictions differ between C-NN and AnyBURL? Table <xref rid="x1-18001-8">8</xref> gives for the four datasets the distribution of test instances into four cases depending on the Hits@1 success of each approach (C-NN and AnyBURL). If the rank-1 predicted entity is correct, then Hits@1 equals 1, otherwise it equals 0. Case 1/1 means that both approaches are correct, case 1/0 means that C-NN is correct but not AnyBURL, etc. The four cases sum up to 100%.</p>
<p>We consider the null hypothesis that if one approach has lesser performance, then its set of correct predictions is a subset of the correct predictions of the other approach. For instance, on FB15k-237 where AnyBURL is better, we expect that case 0/1 is empty. This is rejected in all four datasets. For instance, on FB15k-237, C-NN is the only correct approach for 4.7% test instances, which amounts to 1918 test instances. Those results demonstrate that C-NN and AnyBURL can complement each other, and that improvement of state-of-the-art performances remains possible. This is made explicit in the last two columns that allow to compare Hits@1 of the best of the two approaches and the best ensemble of the two (union of correct predictions).</p>
<table-wrap id="x1-18001-8">
<label>Table 8</label>
<caption>
<p>Distribution of test instances depending of Hits@1 success of C-NN and AnyBURL. The last two columns give the average Hits@1 first for the best of the two approaches, and second for the best ensemble</p>
</caption>
<table frame="hsides" rules="groups">
<thead>
<tr>
<td valign="top" align="left">Dataset</td>
<td valign="top" align="center">nb. test</td>
<td valign="top" align="center" colspan="4">H@1 C-NN/H@1 AnyBURL</td>
<td valign="top" align="center" colspan="2">H@1</td>
</tr>
<tr>
<td valign="top"/>
<td valign="top"/>
<td valign="top" colspan="4"><hr/></td>
<td valign="top" colspan="2"><hr/></td>
</tr>
<tr>
<td valign="top" align="left"/>
<td valign="top" align="char" char="."/>
<td valign="top" align="center">1/1</td>
<td valign="top" align="center">1/0</td>
<td valign="top" align="center">0/1</td>
<td valign="top" align="center">0/0</td>
<td valign="top" align="center">Best of two</td>
<td valign="top" align="center">Best ensemble</td>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" align="left">WN18</td>
<td valign="top" align="char" char=".">10100</td>
<td valign="top" align="center">93.2</td>
<td valign="top" align="center"><bold>3.4</bold></td>
<td valign="top" align="center">0.9</td>
<td valign="top" align="char" char=".">2.5</td>
<td valign="top" align="center">96.6</td>
<td valign="top" align="center">97.5</td>
</tr>
<tr>
<td valign="top" align="left">WN18RR</td>
<td valign="top" align="char" char=".">6268</td>
<td valign="top" align="center">41.3</td>
<td valign="top" align="center">3.1</td>
<td valign="top" align="center"><bold>3.6</bold></td>
<td valign="top" align="char" char=".">52.0</td>
<td valign="top" align="center">44.9</td>
<td valign="top" align="center">48.0</td>
</tr>
<tr>
<td valign="top" align="left">FB15k</td>
<td valign="top" align="char" char=".">118142</td>
<td valign="top" align="center">75.3</td>
<td valign="top" align="center"><bold>7.4</bold></td>
<td valign="top" align="center">5.5</td>
<td valign="top" align="char" char=".">11.8</td>
<td valign="top" align="center">82.7</td>
<td valign="top" align="center">88.2</td>
</tr>
<tr>
<td valign="top" align="left">FB15k-237</td>
<td valign="top" align="char" char=".">40932</td>
<td valign="top" align="center">17.5</td>
<td valign="top" align="center">4.7</td>
<td valign="top" align="center"><bold>6.2</bold></td>
<td valign="top" align="char" char=".">71.6</td>
<td valign="top" align="center">23.7</td>
<td valign="top" align="center">28.4</td>
</tr>
</tbody>
</table>
</table-wrap>
<p>We now detail a few test instances where C-NN and AnyBURL differ (cases 1/0 and 0/1). The analysis is limited by the fact that AnyBURL’s code does not output rules as explanations for predictions (although the code could be modified to do so). Here are a few test instances where C-NN succeeds while AnyBURL fails: 
<list list-type="bullet">
<list-item>
<p>Wichita falls were correctly predicted to have Central Time Zone because it is contained in Texas (by-copy rule, support = 31, confidence = 0.79);</p>
</list-item>
<list-item>
<p>Joe Shuster was correctly predicted to have written “Superman II: The Richard Donner Cut” because he has produced a story that was honored for the film, and he won some award (by-analogy rule, support = 5, confidence = 0.36);</p>
</list-item>
<list-item>
<p>Joe Shuster was also correctly predicted to live in Cleveland because he has produced the story “Superman II” (by-copy rule, support = 1, confidence = 0.33). Here the explanation is not so convincing because of the very low support;</p>
</list-item>
<list-item>
<p>Film “Good Will Hunting” was correctly predicted to have two crew roles “make-up artist” and “special effects supervisor” because it was nominated for the “Satellite Award for Best Original Screenplay” (by-copy rule, support = 16, confidence = 0.78). Here the rule is probably overly specific as most films probably have the two crew roles, not only those nominated for the “Satellite Award…”. Post-processing would be useful to remove the redundant parts.</p>
</list-item>
</list> 
Those C-NN rules could be found by AnyBURL, so they do not exhibit real limits of AnyBURL. However, all those rules except the second contain equality filters (constants in AnyBURL’s terminology), and the number of such rules is extremely large, even for small rules, because of the high number of entities in KGs. C-NN here has the advantage that it only needs to generate rules for a given test instance (instance-based learning), while AnyBURL has to generate the rules before seeing any test instance (model-based learning). We can therefore expect C-NN to have a better coverage of such rules.</p>
<p>Now, here are test instances where C-NN fails while AnyBURL succeeds. In each instance, we give the best C-NN rule, which fails, and then the “successful C-NN rule”, i.e. the highest-confidence rule found by our approach that infers the correct entity. 
<list list-type="bullet">
<list-item>
<p>Lily Tomlin was incorrectly predicted to be nominated for TV series “Murphy Brown”, instead of “The West Wing” (predicted 2nd), because he is an actor of the TV series, and won an award (by-analogy rule, support = 364, confidence = 0.53). The successful rule predicts “The West Wing” because he was nominated along with Joshua Malina (by-copy rule, support = 14, confidence = 0.50);</p>
</list-item>
<list-item>
<p>Film “Life is beautiful” was incorrectly predicted to have genre Italian, instead of War Film (predicted 8th), because it appears on the title list of the Netflix genre “Italian” (by-analogy rule, support = 393, confidence = 0.56). The successful rule predicts War Film because it was produced in Italy (by-copy rule, support = 14, confidence = 0.25).</p>
</list-item>
</list> 
It is difficult to derive conclusions without knowing the successful AnyBURL’s rules. Still, it can be observed that errors made by C-NN are reasonable ones. In the second example, the successful rule has weaker measures of support and confidence, and is less intuitive than the unsuccessful one. In reality, the film “Life is beautiful” has both genres “Italian” and “War Film”, but the gold standard only contains the second. One must keep in mind that what is used as gold standard in those experiments are actually incomplete (and possibly incorrect) knowledge graphs.</p>
</sec>
</sec>
<sec id="x1-19000-8">
<label>8.</label>
<title>Conclusion</title>
<p>We have shown that a symbolic approach to the problem of knowledge graph completion can be competitive with state-of-the-art approaches, both latent-based and rule-based. This comes with the major advantage that our approach can provide detailed explanations for each inference, in terms of the graph features. Compared to rule-based approaches, which can provide similar explanations, we follow an instance-based approach, and hence avoid the need for a training phase that can be costly in runtime and memory (rule mining), in particular with dynamic data. Moreover, our rule language bias is weaker by allowing arbitrary conjunctive rules with constants, while avoiding a combinatorial explosion thanks to our instance-based approach and our partitioning algorithm. Our approach is analogous to classification with k-nearest neighbours but our distances are defined as partially-ordered graph concepts instead of numbers.</p>
<p>There are many tracks for future work. Extending graph patterns with n-ary relations and richer filters over numbers, dates, etc. Optimizing and scaling the computation of C-NNs by finding good strategies to drive the partitioning process, or by parallelizing it. Improving the selection and display of rules as explanations. Evaluating our approach on other datasets, and other inference tasks.</p>
</sec>
</body>
<back>
<ack>
<title>Acknowledgements</title>
<p>I kindly thank the reviewers for their insightful remarks, and valuable suggestions, which contributed to significantly improve this paper.</p></ack>
<ref-list>
<title>References</title>
<ref id="ref001">
<label>[1]</label><mixed-citation publication-type="chapter"><string-name><given-names>R.</given-names> <surname>Agrawal</surname></string-name>, <string-name><given-names>R.</given-names> <surname>Srikant</surname></string-name> <etal>et al.</etal>, <chapter-title>Fast algorithms for mining association rules</chapter-title>, in: <source>Int. Conf. Very Large Data Bases (VLDB)</source>, Vol. <volume>1215</volume>, <year>1994</year>, pp. <fpage>487</fpage>–<lpage>499</lpage>, <uri>http://vldb.org/conf/1994/P487.PDF</uri>.</mixed-citation>
</ref>
<ref id="ref002">
<label>[2]</label><mixed-citation publication-type="journal"><string-name><given-names>T.</given-names> <surname>Berners-Lee</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Hendler</surname></string-name> and <string-name><given-names>O.</given-names> <surname>Lassila</surname></string-name>, <article-title>The semantic web</article-title>, <source>Scientific American</source> <volume>284</volume>(<issue>5</issue>) (<year>2001</year>), <fpage>34</fpage>–<lpage>43</lpage>. doi:<pub-id pub-id-type="doi">10.1038/scientificamerican0501-34</pub-id>.</mixed-citation>
</ref>
<ref id="ref003">
<label>[3]</label><mixed-citation publication-type="other"><string-name><given-names>C.</given-names> <surname>Bizer</surname></string-name> and <string-name><given-names>A.</given-names> <surname>Schultz</surname></string-name>, <article-title>The berlin sparql benchmark</article-title>, <source>Int. J. Semantic Web and Information Systems</source> <volume>5</volume>(<issue>2</issue>) (<year>2009</year>). doi:<pub-id pub-id-type="doi">10.4018/jswis.2009040101</pub-id>.</mixed-citation>
</ref>
<ref id="ref004">
<label>[4]</label><mixed-citation publication-type="chapter"><string-name><given-names>A.</given-names> <surname>Bordes</surname></string-name>, <string-name><given-names>N.</given-names> <surname>Usunier</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Garcia-Duran</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Weston</surname></string-name> and <string-name><given-names>O.</given-names> <surname>Yakhnenko</surname></string-name>, <chapter-title>Translating embeddings for modeling multi-relational data</chapter-title>, in: <source>Advances in Neural Information Processing Systems</source>, <year>2013</year>, pp. <fpage>2787</fpage>–<lpage>2795</lpage>.</mixed-citation>
</ref>
<ref id="ref005">
<label>[5]</label><mixed-citation publication-type="journal"><string-name><given-names>T.</given-names> <surname>Denœux</surname></string-name>, <article-title>A k-nearest neighbor classification rule based on Dempster–Shafer theory</article-title>, <source>IEEE Trans. Systems, Man, and Cybernetics</source> <volume>25</volume>(<issue>5</issue>) (<year>1995</year>), <fpage>804</fpage>–<lpage>813</lpage>. doi:<pub-id pub-id-type="doi">10.1109/21.376493</pub-id>.</mixed-citation>
</ref>
<ref id="ref006">
<label>[6]</label><mixed-citation publication-type="chapter"><string-name><given-names>T.</given-names> <surname>Dettmers</surname></string-name>, <string-name><given-names>P.</given-names> <surname>Minervini</surname></string-name>, <string-name><given-names>P.</given-names> <surname>Stenetorp</surname></string-name> and <string-name><given-names>S.</given-names> <surname>Riedel</surname></string-name>, <chapter-title>Convolutional 2D knowledge graph embeddings</chapter-title>, in: <source>Conf. Artificial Intelligence (AAAI)</source>, <string-name><given-names>S.A.</given-names> <surname>McIlraith</surname></string-name> and <string-name><given-names>K.Q.</given-names> <surname>Weinberger</surname></string-name>, eds, <publisher-name>AAAI Press</publisher-name>, <year>2018</year>, pp. <fpage>1811</fpage>–<lpage>1818</lpage>, <uri>https://www.aaai.org/ocs/index.php/AAAI/AAAI18/paper/viewPaper/17366</uri>.</mixed-citation>
</ref>
<ref id="ref007">
<label>[7]</label><mixed-citation publication-type="chapter"><string-name><given-names>S.</given-names> <surname>Ferré</surname></string-name>, <chapter-title>Concepts de plus proches voisins dans des graphes de connaissances</chapter-title>, in: <source>Ingénierie des Connaissances (IC)</source>, <year>2017</year>, pp. <fpage>163</fpage>–<lpage>174</lpage>, <uri>https://hal.archives-ouvertes.fr/hal-01570277</uri>.</mixed-citation>
</ref>
<ref id="ref008">
<label>[8]</label><mixed-citation publication-type="chapter"><string-name><given-names>S.</given-names> <surname>Ferré</surname></string-name>, <chapter-title>Answers partitioning and lazy joins for efficient query relaxation and application to similarity search</chapter-title>, in: <source>Int. Conf. the Semantic Web (ESWC)</source>, <string-name><given-names>A.</given-names> <surname>Gangemi</surname></string-name> <etal>et al.</etal>, eds, <series>LNCS</series>, Vol. <volume>10843</volume>, <publisher-name>Springer</publisher-name>, <year>2018</year>, pp. <fpage>209</fpage>–<lpage>224</lpage>. doi:<pub-id pub-id-type="doi">10.1007/978-3-319-93417-4_14</pub-id>.</mixed-citation>
</ref>
<ref id="ref009">
<label>[9]</label><mixed-citation publication-type="chapter"><string-name><given-names>S.</given-names> <surname>Ferré</surname></string-name>, <chapter-title>Link prediction in knowledge graphs with concepts of nearest neighbours</chapter-title>, in: <source>The Semantic Web (ESWC)</source>, <string-name><given-names>P.</given-names> <surname>Hitzler</surname></string-name> <etal>et al.</etal>, eds, <series>LNCS</series>, Vol. <volume>11503</volume>, <publisher-name>Springer</publisher-name>, <year>2019</year>, pp. <fpage>84</fpage>–<lpage>100</lpage>. doi:<pub-id pub-id-type="doi">10.1007/978-3-030-21348-0_6</pub-id>.</mixed-citation>
</ref>
<ref id="ref010">
<label>[10]</label><mixed-citation publication-type="journal"><string-name><given-names>S.</given-names> <surname>Ferré</surname></string-name> and <string-name><given-names>P.</given-names> <surname>Cellier</surname></string-name>, <article-title>Graph-FCA: An extension of formal concept analysis to knowledge graphs</article-title>, <source>Discrete Applied Mathematics</source> <volume>273</volume> (<year>2019</year>), <fpage>81</fpage>–<lpage>102</lpage>. doi:<pub-id pub-id-type="doi">10.1016/j.dam.2019.03.003</pub-id>.</mixed-citation>
</ref>
<ref id="ref011">
<label>[11]</label><mixed-citation publication-type="journal"><string-name><given-names>L.</given-names> <surname>Galárraga</surname></string-name>, <string-name><given-names>C.</given-names> <surname>Teflioudi</surname></string-name>, <string-name><given-names>K.</given-names> <surname>Hose</surname></string-name> and <string-name><given-names>F.</given-names> <surname>Suchanek</surname></string-name>, <article-title>Fast rule mining in ontological knowledge bases with AMIE+</article-title>, <source>Int. J. Very Large Data Bases</source> <volume>24</volume>(<issue>6</issue>) (<year>2015</year>), <fpage>707</fpage>–<lpage>730</lpage>. doi:<pub-id pub-id-type="doi">10.1007/s00778-015-0394-1</pub-id>.</mixed-citation>
</ref>
<ref id="ref012">
<label>[12]</label><mixed-citation publication-type="other"><string-name><given-names>B.</given-names> <surname>Ganter</surname></string-name> and <string-name><given-names>R.</given-names> <surname>Wille</surname></string-name>, <source>Formal Concept Analysis – Mathematical Foundations</source>, <publisher-name>Springer</publisher-name>, <year>1999</year>. doi:<pub-id pub-id-type="doi">10.1007/978-3-642-59830-2</pub-id>.</mixed-citation>
</ref>
<ref id="ref013">
<label>[13]</label><mixed-citation publication-type="chapter"><string-name><given-names>A.</given-names> <surname>García-Durán</surname></string-name> and <string-name><given-names>M.</given-names> <surname>Niepert</surname></string-name>, <chapter-title>KBlrn: End-to-end learning of knowledge base representations with latent, relational, and numerical features</chapter-title>, in: <source>Conf. Uncertainty in Artificial Intelligence (UAI)</source>, <string-name><given-names>A.</given-names> <surname>Globerson</surname></string-name> and <string-name><given-names>R.</given-names> <surname>Silva</surname></string-name>, eds, <publisher-name>AUAI Press</publisher-name>, <year>2018</year>, pp. <fpage>372</fpage>–<lpage>381</lpage>, <uri>http://auai.org/uai2018/proceedings/papers/149.pdf</uri>.</mixed-citation>
</ref>
<ref id="ref014">
<label>[14]</label><mixed-citation publication-type="journal"><string-name><given-names>Y.</given-names> <surname>Guo</surname></string-name>, <string-name><given-names>Z.</given-names> <surname>Pan</surname></string-name> and <string-name><given-names>J.</given-names> <surname>Heflin</surname></string-name>, <article-title>LUBM: A benchmark for OWL knowledge base systems</article-title>, <source>Journal of Web Semantics: Science, Services and Agents</source> <volume>3</volume>(<issue>2–3</issue>) (<year>2005</year>), <fpage>158</fpage>–<lpage>182</lpage>. doi:<pub-id pub-id-type="doi">10.1016/j.websem.2005.06.005</pub-id>.</mixed-citation>
</ref>
<ref id="ref015">
<label>[15]</label><mixed-citation publication-type="chapter"><string-name><given-names>A.</given-names> <surname>Hermann</surname></string-name>, <string-name><given-names>S.</given-names> <surname>Ferré</surname></string-name> and <string-name><given-names>M.</given-names> <surname>Ducassé</surname></string-name>, <chapter-title>An interactive guidance process supporting consistent updates of RDFS graphs</chapter-title>, in: <source>Int. Conf. Knowledge Engineering and Knowledge Management (EKAW)</source>, <string-name><given-names>A.</given-names> <surname>ten Teije</surname></string-name> <etal>et al.</etal>, eds, <series>LNAI</series>, Vol. <volume>7603</volume>, <publisher-name>Springer</publisher-name>, <year>2012</year>, pp. <fpage>185</fpage>–<lpage>199</lpage>. doi:<pub-id pub-id-type="doi">10.1007/978-3-642-33876-2_18</pub-id>.</mixed-citation>
</ref>
<ref id="ref016">
<label>[16]</label><mixed-citation publication-type="other"><string-name><given-names>P.</given-names> <surname>Hitzler</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Krötzsch</surname></string-name> and <string-name><given-names>S.</given-names> <surname>Rudolph</surname></string-name>, <source>Foundations of Semantic Web Technologies</source>, <publisher-name>Chapman &amp; Hall/CRC</publisher-name>, <year>2009</year>. ISBN <isbn>9781420090505</isbn>. doi:<pub-id pub-id-type="doi">10.1201/9781420090512</pub-id>.</mixed-citation>
</ref>
<ref id="ref017">
<label>[17]</label><mixed-citation publication-type="chapter"><string-name><given-names>C.A.</given-names> <surname>Hurtado</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Poulovassilis</surname></string-name> and <string-name><given-names>P.T.</given-names> <surname>Wood</surname></string-name>, <chapter-title>Query relaxation in RDF</chapter-title>, in: <source>Journal on Data Semantics X</source>, <string-name><given-names>S.</given-names> <surname>Spaccapietra</surname></string-name>, ed., <series>LNCS</series>, Vol. <volume>4900</volume>, <publisher-name>Springer</publisher-name>, <year>2008</year>, pp. <fpage>31</fpage>–<lpage>61</lpage>. doi:<pub-id pub-id-type="doi">10.1007/978-3-540-77688-8_2</pub-id>.</mixed-citation>
</ref>
<ref id="ref018">
<label>[18]</label><mixed-citation publication-type="chapter"><string-name><given-names>T.</given-names> <surname>Lacroix</surname></string-name>, <string-name><given-names>N.</given-names> <surname>Usunier</surname></string-name> and <string-name><given-names>G.</given-names> <surname>Obozinski</surname></string-name>, <chapter-title>Canonical tensor decomposition for knowledge base completion</chapter-title>, in: <source>Int. Conf. Machine Learning (ICML)</source>, <string-name><given-names>J.G.</given-names> <surname>Dy</surname></string-name> and <string-name><given-names>A.</given-names> <surname>Krause</surname></string-name>, eds, <series>Proceedings of Machine Learning Research</series>, Vol. <volume>80</volume>, <publisher-name>PMLR</publisher-name>, <year>2018</year>, pp. <fpage>2869</fpage>–<lpage>2878</lpage>, <uri>http://proceedings.mlr.press/v80/lacroix18a.html</uri>.</mixed-citation>
</ref>
<ref id="ref019">
<label>[19]</label><mixed-citation publication-type="chapter"><string-name><given-names>N.</given-names> <surname>Lao</surname></string-name>, <string-name><given-names>T.</given-names> <surname>Mitchell</surname></string-name> and <string-name><given-names>W.W.</given-names> <surname>Cohen</surname></string-name>, <chapter-title>Random walk inference and learning in a large scale knowledge base</chapter-title>, in: <source>Conf. Empirical Methods in Natural Language Processing</source>, <publisher-name>Association for Computational Linguistics</publisher-name>, <year>2011</year>, pp. <fpage>529</fpage>–<lpage>539</lpage>, <uri>https://www.aclweb.org/anthology/D11-1049.pdf</uri>.</mixed-citation>
</ref>
<ref id="ref020">
<label>[20]</label><mixed-citation publication-type="journal"><string-name><given-names>D.</given-names> <surname>Liben-Nowell</surname></string-name> and <string-name><given-names>J.</given-names> <surname>Kleinberg</surname></string-name>, <article-title>The link-prediction problem for social networks</article-title>, <source>Journal of the American Society for Information Science and Technology</source> <volume>58</volume>(<issue>7</issue>) (<year>2007</year>), <fpage>1019</fpage>–<lpage>1031</lpage>. doi:<pub-id pub-id-type="doi">10.1002/asi.20591</pub-id>.</mixed-citation>
</ref>
<ref id="ref021">
<label>[21]</label><mixed-citation publication-type="chapter"><string-name><given-names>H.</given-names> <surname>Liu</surname></string-name>, <string-name><given-names>Y.</given-names> <surname>Wu</surname></string-name> and <string-name><given-names>Y.</given-names> <surname>Yang</surname></string-name>, <chapter-title>Analogical inference for multi-relational embeddings</chapter-title>, in: <source>Int. Conf. Machine Learning (ICML)</source>, <string-name><given-names>D.</given-names> <surname>Precup</surname></string-name> and <string-name><given-names>Y.W.</given-names> <surname>Teh</surname></string-name>, eds, <series>Proceedings of Machine Learning Research</series>, Vol. <volume>70</volume>, <publisher-name>PMLR</publisher-name>, <year>2017</year>, pp. <fpage>2168</fpage>–<lpage>2178</lpage>, <uri>http://proceedings.mlr.press/v70/liu17d.html</uri>.</mixed-citation>
</ref>
<ref id="ref022">
<label>[22]</label><mixed-citation publication-type="other"><string-name><given-names>W.</given-names> <surname>May</surname></string-name>, Information extraction and integration with <sc>Florid</sc>: The <sc>Mondial</sc> case study, Technical Report 131, Universität Freiburg, Institut für Informatik, 1999, <uri>http://dbis.informatik.uni-goettingen.de/Mondial</uri>.</mixed-citation>
</ref>
<ref id="ref023">
<label>[23]</label><mixed-citation publication-type="chapter"><string-name><given-names>C.</given-names> <surname>Meilicke</surname></string-name>, <string-name><given-names>M.W.</given-names> <surname>Chekol</surname></string-name>, <string-name><given-names>D.</given-names> <surname>Ruffinelli</surname></string-name> and <string-name><given-names>H.</given-names> <surname>Stuckenschmidt</surname></string-name>, <chapter-title>Anytime bottom-up rule learning for knowledge graph completion</chapter-title>, in: <source>Int. Joint Conf. Artificial Intelligence (IJCAI)</source>, <string-name><given-names>S.</given-names> <surname>Kraus</surname></string-name>, ed., <publisher-name>ijcai.org</publisher-name>, <year>2019</year>, pp. <fpage>3137</fpage>–<lpage>3143</lpage>. doi:<pub-id pub-id-type="doi">10.24963/ijcai.2019/435</pub-id>.</mixed-citation>
</ref>
<ref id="ref024">
<label>[24]</label><mixed-citation publication-type="chapter"><string-name><given-names>C.</given-names> <surname>Meilicke</surname></string-name>, <string-name><given-names>M.</given-names> <surname>Fink</surname></string-name>, <string-name><given-names>Y.</given-names> <surname>Wang</surname></string-name>, <string-name><given-names>D.</given-names> <surname>Ruffinelli</surname></string-name>, <string-name><given-names>R.</given-names> <surname>Gemulla</surname></string-name> and <string-name><given-names>H.</given-names> <surname>Stuckenschmidt</surname></string-name>, <chapter-title>Fine-grained evaluation of rule- and embedding-based systems for knowledge graph completion</chapter-title>, in: <source>The Semantic Web (ISWC)</source>, <string-name><given-names>D.</given-names> <surname>Vrandecic</surname></string-name> <etal>et al.</etal>, eds, <series>LNCS</series>, Vol. <volume>11136</volume>, <publisher-name>Springer</publisher-name>, <year>2018</year>, pp. <fpage>3</fpage>–<lpage>20</lpage>. doi:<pub-id pub-id-type="doi">10.1007/978-3-030-00671-6_1</pub-id>.</mixed-citation>
</ref>
<ref id="ref025">
<label>[25]</label><mixed-citation publication-type="journal"><string-name><given-names>S.</given-names> <surname>Muggleton</surname></string-name>, <article-title>Inverse entailment and Progol</article-title>, <source>New Generation Computation</source> <volume>13</volume> (<year>1995</year>), <fpage>245</fpage>–<lpage>286</lpage>. doi:<pub-id pub-id-type="doi">10.1007/BF03037227</pub-id>.</mixed-citation>
</ref>
<ref id="ref026">
<label>[26]</label><mixed-citation publication-type="journal"><string-name><given-names>M.</given-names> <surname>Nickel</surname></string-name>, <string-name><given-names>K.</given-names> <surname>Murphy</surname></string-name>, <string-name><given-names>V.</given-names> <surname>Tresp</surname></string-name> and <string-name><given-names>E.</given-names> <surname>Gabrilovich</surname></string-name>, <article-title>A review of relational machine learning for knowledge graphs</article-title>, <source>Proc. IEEE</source> <volume>104</volume>(<issue>1</issue>) (<year>2016</year>), <fpage>11</fpage>–<lpage>33</lpage>. doi:<pub-id pub-id-type="doi">10.1109/JPROC.2015.2483592</pub-id>.</mixed-citation>
</ref>
<ref id="ref027">
<label>[27]</label><mixed-citation publication-type="chapter"><string-name><given-names>P.G.</given-names> <surname>Omran</surname></string-name>, <string-name><given-names>K.</given-names> <surname>Wang</surname></string-name> and <string-name><given-names>Z.</given-names> <surname>Wang</surname></string-name>, <chapter-title>Scalable rule learning via learning representation</chapter-title>, in: <source>Int. Joint Conf. Artificial Intelligence (IJCAI)</source>, <string-name><given-names>J.</given-names> <surname>Lang</surname></string-name>, ed., <publisher-name>ijcai.org</publisher-name>, <year>2018</year>, pp. <fpage>2149</fpage>–<lpage>2155</lpage>. doi:<pub-id pub-id-type="doi">10.24963/ijcai.2018/297</pub-id>.</mixed-citation>
</ref>
<ref id="ref028">
<label>[28]</label><mixed-citation publication-type="other"><string-name><given-names>G.D.</given-names> <surname>Plotkin</surname></string-name>, Automatic methods of inductive inference, PhD thesis, Edinburgh University, 1971, <uri>https://era.ed.ac.uk/bitstream/handle/1842/6656/Plotkin1972.pdf</uri>.</mixed-citation>
</ref>
<ref id="ref029">
<label>[29]</label><mixed-citation publication-type="chapter"><string-name><given-names>M.</given-names> <surname>Schlichtkrull</surname></string-name>, <string-name><given-names>T.N.</given-names> <surname>Kipf</surname></string-name>, <string-name><given-names>P.</given-names> <surname>Bloem</surname></string-name>, <string-name><given-names>R.</given-names> <surname>van den Berg</surname></string-name>, <string-name><given-names>I.</given-names> <surname>Titov</surname></string-name> and <string-name><given-names>M.</given-names> <surname>Welling</surname></string-name>, <chapter-title>Modeling relational data with graph convolutional networks</chapter-title>, in: <source>The Semantic Web Conf. (ESWC)</source>, <publisher-name>Springer</publisher-name>, <year>2018</year>, pp. <fpage>593</fpage>–<lpage>607</lpage>. doi:<pub-id pub-id-type="doi">10.1007/978-3-319-93417-4_38</pub-id>.</mixed-citation>
</ref>
<ref id="ref030">
<label>[30]</label><mixed-citation publication-type="chapter"><string-name><given-names>K.</given-names> <surname>Toutanova</surname></string-name> and <string-name><given-names>D.</given-names> <surname>Chen</surname></string-name>, <chapter-title>Observed versus latent features for knowledge base and text inference</chapter-title>, in: <source>Work. Continuous Vector Space Models and Their Compositionality</source>, <year>2015</year>, pp. <fpage>57</fpage>–<lpage>66</lpage>. doi:<pub-id pub-id-type="doi">10.18653/v1/W15-4007</pub-id>.</mixed-citation>
</ref>
<ref id="ref031">
<label>[31]</label><mixed-citation publication-type="other"><string-name><given-names>B.</given-names> <surname>Yang</surname></string-name>, <string-name><given-names>W.</given-names> <surname>Yih</surname></string-name>, <string-name><given-names>X.</given-names> <surname>He</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Gao</surname></string-name> and <string-name><given-names>L.</given-names> <surname>Deng</surname></string-name>, <chapter-title>Embedding entities and relations for learning and inference in knowledge bases</chapter-title>, in: <source>Int. Conf. Learning Representations (ICLR)</source>, <string-name><given-names>Y.</given-names> <surname>Bengio</surname></string-name> and <string-name><given-names>Y.</given-names> <surname>LeCun</surname></string-name>, eds, <year>2015</year>, <uri>http://arxiv.org/abs/1412.6575</uri>.</mixed-citation>
</ref>
<ref id="ref032">
<label>[32]</label><mixed-citation publication-type="chapter"><string-name><given-names>R.</given-names> <surname>Zhang</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Li</surname></string-name>, <string-name><given-names>J.</given-names> <surname>Mei</surname></string-name> and <string-name><given-names>Y.</given-names> <surname>Mao</surname></string-name>, <chapter-title>Scalable instance reconstruction in knowledge bases via relatedness affiliated embedding</chapter-title>, in: <source>Conf. World Wide Web (WWW)</source>, <year>2018</year>, pp. <fpage>1185</fpage>–<lpage>1194</lpage>. doi:<pub-id pub-id-type="doi">10.1145/3178876.3186017</pub-id>.</mixed-citation>
</ref>
<ref id="ref033">
<label>[33]</label><mixed-citation publication-type="chapter"><string-name><given-names>W.</given-names> <surname>Zhang</surname></string-name>, <string-name><given-names>B.</given-names> <surname>Paudel</surname></string-name>, <string-name><given-names>W.</given-names> <surname>Zhang</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Bernstein</surname></string-name> and <string-name><given-names>H.</given-names> <surname>Chen</surname></string-name>, <chapter-title>Interaction embeddings for prediction and explanation in knowledge graphs</chapter-title>, in: <source>Int. Conf. Web Search and Data Mining (WSDM)</source>, <string-name><given-names>J.S.</given-names> <surname>Culpepper</surname></string-name>, <string-name><given-names>A.</given-names> <surname>Moffat</surname></string-name>, <string-name><given-names>P.N.</given-names> <surname>Bennett</surname></string-name> and <string-name><given-names>K.</given-names> <surname>Lerman</surname></string-name>, eds, <publisher-name>ACM</publisher-name>, <year>2019</year>, pp. <fpage>96</fpage>–<lpage>104</lpage>. doi:<pub-id pub-id-type="doi">10.1145/3289600.3291014</pub-id>.</mixed-citation>
</ref>
</ref-list>
</back>
</article>
